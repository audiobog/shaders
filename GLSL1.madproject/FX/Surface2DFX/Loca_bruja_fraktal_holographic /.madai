{
    "editions": [
        {
            "code": "/*\n\tAvailable uniforms:\n\n\t\t// mm_ModulationColor contains red, green, blue levels & surface opacity in alpha\n\t\t// The multiplication in the fragment shader is done by MadMapper, so you shouldn't need that\n\t\tuniform vec4 mm_ModulationColor;\n\n\t\t// Blend Mode, see possible values in Definitions below. This is handled by default by MadMapper so you should need it\n\t\tuniform int mm_BlendMode;\n\n\t\t// Used to know if we're rendering to the preview or to an output fullscreen / desktop window / syphon-spout-NDI\n\t\tuniform bool mm_IsRenderingPreview;\n\n\t\t// The index of the surface in the project (not recommended to use that)\n\t\tuniform int mm_SurfaceIndex;\n\n\tAvailable inputs:\n\n\t\t// The normalized texture coordinate for this pixel. Should be accessed with \"vec4 FX_NORM_PIXEL(vec2 uv)\"\n\t\tin vec2 mm_FragNormCoord;\n\n\t    // Normalized position of this vertex in the surface output geometry (independent of input rectangle)\n\t\tin vec2 mm_SurfaceCoord;\n\n\t\t// Alpha of this point generated from surface / mask feathering. This is automatically handled by MadMapper and\n\t\t// should not be used in an FX\n\t\tin float mm_Alpha;\n\n\n\tMain Fragment Shader calls fxColorForPixel(...) and then apply modulation color and transparency (feathering / masking),\n\tthen might adjust color depending on blending mode / highlight selection...\n\n*/\n\n/*{\n    \"CREDIT\": \"MadTeam\",\n    \"TAGS\": [\"graphics\"],\n    \"VSN\": 1.0,\n    \"DESCRIPTION\": \"Describe your FX here\",\n    \"MEDIA\": {\n        \"REQUIRES_TEXTURE\": false,\n        \"GL_TEXTURE_MIN_FILTER\": \"LINEAR\",\n        \"GL_TEXTURE_MAG_FILTER\": \"LINEAR\",\n        \"GL_TEXTURE_WRAP\": \"CLAMP_TO_EDGE\",\n    },\n    \"INPUTS\": [\n        { \"LABEL\": \"Speed\", \"NAME\": \"fx_speed\", \"TYPE\": \"float\", \"DEFAULT\": 0.1, \"MIN\": 0.0, \"MAX\": 1.0 },\n    ],\n    \"GENERATORS\": [\n        {\"NAME\": \"fx_time\", \"TYPE\": \"time_base\", \"PARAMS\": {\"speed\": \"fx_speed\", \"speed_curve\": 2, \"link_speed_to_global_bpm\":true}},\n    ]\n}*/\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n\tvec2 uv;\n\tuv.x = fract(mm_FragNormCoord.x+fx_time);\n\tuv.y = mm_FragNormCoord.y;\n    return FX_NORM_PIXEL(uv);\n}\n",
            "isPrompt": false,
            "madness": 0.5,
            "mode": "",
            "title": "New"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"Made with MadAI\",\n  \"DESCRIPTION\": \"Glossy holographic fractal with audio reactivity\",\n  \"TAGS\": \"fractal,holographic,audio,3d,glossy\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Fractal/Zoom\", \"NAME\": \"fx_zoom\", \"TYPE\": \"float\", \"DEFAULT\": 1.5, \"MIN\": 0.1, \"MAX\": 5.0, \"DESCRIPTION\": \"Fractal zoom level\" },\n    { \"LABEL\": \"Fractal/Iterations\", \"NAME\": \"fx_iterations\", \"TYPE\": \"int\", \"DEFAULT\": 64, \"MIN\": 8, \"MAX\": 256, \"DESCRIPTION\": \"Fractal iterations\" },\n    { \"LABEL\": \"Animation/Speed\", \"NAME\": \"fx_anim_speed\", \"TYPE\": \"float\", \"DEFAULT\": 0.5, \"MIN\": 0.0, \"MAX\": 2.0, \"DESCRIPTION\": \"Animation speed\" },\n    { \"LABEL\": \"Depth/Scale\", \"NAME\": \"fx_depth\", \"TYPE\": \"float\", \"DEFAULT\": 1.0, \"MIN\": 0.0, \"MAX\": 3.0, \"DESCRIPTION\": \"3D depth effect\" },\n    { \"LABEL\": \"Audio/Bass Warp\", \"NAME\": \"fx_bass_amount\", \"TYPE\": \"float\", \"DEFAULT\": 0.5, \"MIN\": 0.0, \"MAX\": 2.0, \"DESCRIPTION\": \"Bass distortion\" },\n    { \"LABEL\": \"Audio/Mid Rotation\", \"NAME\": \"fx_mid_rotation\", \"TYPE\": \"float\", \"DEFAULT\": 1.0, \"MIN\": 0.0, \"MAX\": 2.0, \"DESCRIPTION\": \"Mid rotation\" },\n    { \"LABEL\": \"Audio/Glitter\", \"NAME\": \"fx_glitter\", \"TYPE\": \"float\", \"DEFAULT\": 1.0, \"MIN\": 0.0, \"MAX\": 2.0, \"DESCRIPTION\": \"High freq glitter\" },\n    { \"LABEL\": \"Glossiness\", \"NAME\": \"fx_glossiness\", \"TYPE\": \"float\", \"DEFAULT\": 0.8, \"MIN\": 0.0, \"MAX\": 1.0, \"DESCRIPTION\": \"Surface glossiness\" },\n    { \"LABEL\": \"Audio/Smoothing\", \"NAME\": \"fx_audio_smooth\", \"TYPE\": \"float\", \"DEFAULT\": 0.1, \"MIN\": 0.0, \"MAX\": 0.5, \"DESCRIPTION\": \"Audio smoothing\" },\n    { \"NAME\": \"fx_waveformFFT\", \"TYPE\": \"audioFFT\", \"SIZE\": 3, \"RELEASE\": \"fx_audio_smooth\", \"ATTACK\": 0 }\n  ],\n  \"GENERATORS\": [\n    { \"NAME\": \"fx_anim_time\", \"TYPE\": \"time_base\", \"PARAMS\": {\"speed\": \"fx_anim_speed\", \"bpm_sync\": false} }\n  ]\n}*/\n\n#ifndef PI\n#define PI 3.14159265359\n#endif\n\nfloat f_hash(vec2 p_uv) {\n  float v_h = dot(p_uv, vec2(12.9898, 78.233));\n  return fract(sin(v_h) * 43758.5453);\n}\n\nfloat f_noise(vec2 p_uv) {\n  vec2 v_i = floor(p_uv);\n  vec2 v_f = fract(p_uv);\n  v_f = v_f * v_f * (3.0 - 2.0 * v_f);\n  \n  float v_a = f_hash(v_i);\n  float v_b = f_hash(v_i + vec2(1.0, 0.0));\n  float v_c = f_hash(v_i + vec2(0.0, 1.0));\n  float v_d = f_hash(v_i + vec2(1.0, 1.0));\n  \n  float v_ab = mix(v_a, v_b, v_f.x);\n  float v_cd = mix(v_c, v_d, v_f.x);\n  return mix(v_ab, v_cd, v_f.y);\n}\n\nvec2 f_rotate(vec2 p_uv, float p_angle) {\n  float v_c = cos(p_angle);\n  float v_s = sin(p_angle);\n  return vec2(p_uv.x * v_c - p_uv.y * v_s, p_uv.x * v_s + p_uv.y * v_c);\n}\n\nvec2 f_mandelbrot_iter(vec2 p_z, vec2 p_c) {\n  return vec2(p_z.x * p_z.x - p_z.y * p_z.y + p_c.x, 2.0 * p_z.x * p_z.y + p_c.y);\n}\n\nfloat f_mandelbrot(vec2 p_uv, int p_iter) {\n  vec2 v_z = vec2(0.0);\n  float v_escape = 0.0;\n  \n  for(int i = 0; i < 256; i++) {\n    if(i >= p_iter) break;\n    \n    if(dot(v_z, v_z) > 4.0) {\n      v_escape = float(i) / float(p_iter);\n      break;\n    }\n    \n    v_z = f_mandelbrot_iter(v_z, p_uv);\n  }\n  \n  return v_escape;\n}\n\nvec3 f_holographic_color(float p_val, float p_time) {\n  vec3 v_col = vec3(0.0);\n  \n  v_col += 0.5 + 0.5 * sin(p_val * 8.0 + p_time);\n  v_col += 0.5 + 0.5 * cos(p_val * 12.0 - p_time * 0.7);\n  v_col += 0.5 + 0.5 * sin(p_val * 6.0 + p_time * 1.3);\n  \n  v_col = normalize(v_col);\n  \n  return v_col;\n}\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord) {\n  vec2 v_uv = mm_FragNormCoord;\n  float v_aspect = FX_IMG_SIZE().x / FX_IMG_SIZE().y;\n  v_uv.x *= v_aspect;\n  \n  vec4 v_audio_bass = IMG_NORM_PIXEL(fx_waveformFFT, vec2(0.0, 0.0));\n  vec4 v_audio_mid = IMG_NORM_PIXEL(fx_waveformFFT, vec2(0.5, 0.0));\n  vec4 v_audio_high = IMG_NORM_PIXEL(fx_waveformFFT, vec2(1.0, 0.0));\n  \n  float v_bass = v_audio_bass.x;\n  float v_mid = v_audio_mid.x;\n  float v_high = v_audio_high.x;\n  \n  float v_time = fx_anim_time;\n  \n  vec2 v_center = vec2(0.5 * v_aspect, 0.5);\n  vec2 v_coord = v_uv - v_center;\n  \n  float v_bass_warp = 1.0 + v_bass * fx_bass_amount * 0.5;\n  v_coord *= v_bass_warp;\n  \n  float v_mid_angle = v_mid * fx_mid_rotation * PI * 2.0;\n  v_coord = f_rotate(v_coord, v_mid_angle + v_time * 0.3);\n  \n  float v_zoom = fx_zoom * (1.0 + sin(v_time * 0.5) * 0.3);\n  v_coord /= v_zoom;\n  \n  v_coord += vec2(sin(v_time * 0.3) * 0.3, cos(v_time * 0.4) * 0.3);\n  \n  int v_iter = int(fx_iterations);\n  float v_fractal = f_mandelbrot(v_coord, v_iter);\n  \n  float v_smooth_fractal = smoothstep(0.0, 1.0, v_fractal);\n  \n  vec3 v_base_color = f_holographic_color(v_smooth_fractal, v_time);\n  \n  float v_depth_effect = pow(1.0 - v_smooth_fractal, fx_depth);\n  v_base_color *= 0.7 + v_depth_effect * 0.8;\n  \n  float v_gloss = fx_glossiness;\n  float v_specular = pow(sin(v_fractal * 20.0 + v_time * 2.0) * 0.5 + 0.5, 8.0);\n  v_specular *= v_gloss;\n  \n  float v_glitter_threshold = 0.85;\n  float v_glitter = step(v_glitter_threshold, sin(v_fractal * 50.0 + v_time * 5.0) * 0.5 + 0.5);\n  v_glitter *= v_high * fx_glitter;\n  \n  float v_noise_val = f_noise(v_coord * 10.0 + v_time);\n  v_glitter += v_noise_val * 0.3 * v_high * fx_glitter;\n  \n  vec3 v_final = v_base_color + v_specular * vec3(1.0, 0.8, 0.9);\n  v_final += v_glitter * vec3(1.0, 0.95, 0.8);\n  \n  float v_brightness = 0.3 + 0.7 * (1.0 - v_smooth_fractal);\n  v_final *= v_brightness;\n  \n  v_final = mix(v_final, FX_NORM_PIXEL(mm_FragNormCoord).rgb * 0.3, 0.1);\n  \n  return vec4(v_final, 1.0);\n}",
            "isPrompt": true,
            "madness": 0.6239320039749146,
            "mode": "Faster",
            "title": "Create a MadMapper Material Shader that renders a glossy holographic fractal effect with strong 3D depth. The shader should use time to animate the fractal patterns and create a liquid, prism-like hologram look. Make the shader audio reactive: bass should warp or pulse the fractal, mid frequencies should rotate the structure, and high frequencies should add sparkling glitter or shimmering highlights. No mouse interaction. The shader must always output visible color and work as a Material Shader using the standard MadMapper uniforms: time, resolution, mm_FragNormCoord, and the audio analysis values. Output valid GLSL ES fragment shader code only."
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Fractlas_loca_bruja\",\n  \"CREDIT\": \"La_loca_bruja\",\n  \"DESCRIPTION\": \"Stereographic projection with audio-reactive warping\",\n  \"TAGS\": \"distortion,audio,spherical,warping,fractal\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Distortion/Amount\", \"NAME\": \"fx_distortion\", \"TYPE\": \"float\", \"DEFAULT\": 1.2, \"MIN\": 0.0, \"MAX\": 3.0, \"DESCRIPTION\": \"Warp intensity\" },\n    { \"LABEL\": \"Animation/Speed\", \"NAME\": \"fx_speed\", \"TYPE\": \"float\", \"DEFAULT\": 1.0, \"MIN\": 0.0, \"MAX\": 3.0, \"DESCRIPTION\": \"Animation speed\" },\n    { \"LABEL\": \"Audio/Bass React\", \"NAME\": \"fx_bass_react\", \"TYPE\": \"float\", \"DEFAULT\": 1.0, \"MIN\": 0.0, \"MAX\": 2.0, \"DESCRIPTION\": \"Bass reactivity\" },\n    { \"LABEL\": \"Audio/Mid React\", \"NAME\": \"fx_mid_react\", \"TYPE\": \"float\", \"DEFAULT\": 1.0, \"MIN\": 0.0, \"MAX\": 2.0, \"DESCRIPTION\": \"Mid reactivity\" },\n    { \"LABEL\": \"Audio/Treble React\", \"NAME\": \"fx_treble_react\", \"TYPE\": \"float\", \"DEFAULT\": 1.0, \"MIN\": 0.0, \"MAX\": 2.0, \"DESCRIPTION\": \"Treble reactivity\" },\n    { \"LABEL\": \"Warp/Fractal Depth\", \"NAME\": \"fx_fractal_depth\", \"TYPE\": \"float\", \"DEFAULT\": 2.0, \"MIN\": 0.5, \"MAX\": 5.0, \"DESCRIPTION\": \"Fractal iteration depth\" },\n    { \"LABEL\": \"Projection/Radius\", \"NAME\": \"fx_proj_radius\", \"TYPE\": \"float\", \"DEFAULT\": 1.5, \"MIN\": 0.5, \"MAX\": 3.0, \"DESCRIPTION\": \"Sphere projection radius\" },\n    { \"NAME\": \"fx_waveformFFT\", \"TYPE\": \"audioFFT\", \"SIZE\": 3, \"RELEASE\": 0.1, \"ATTACK\": 0 }\n  ],\n  \"GENERATORS\": [\n    { \"NAME\": \"fx_anim_time\", \"TYPE\": \"time_base\", \"PARAMS\": {\"speed\": \"fx_speed\", \"bpm_sync\": false} }\n  ]\n}*/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifndef PI\n#define PI 3.14159265359\n#endif\n\nfloat f_hash(vec2 p_pos) {\n  return fract(sin(dot(p_pos, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat f_noise(vec2 p_pos) {\n  vec2 v_i = floor(p_pos);\n  vec2 v_f = fract(p_pos);\n  vec2 v_u = v_f * v_f * (3.0 - 2.0 * v_f);\n  \n  float v_n00 = f_hash(v_i + vec2(0.0, 0.0));\n  float v_n10 = f_hash(v_i + vec2(1.0, 0.0));\n  float v_n01 = f_hash(v_i + vec2(0.0, 1.0));\n  float v_n11 = f_hash(v_i + vec2(1.0, 1.0));\n  \n  float v_nx0 = mix(v_n00, v_n10, v_u.x);\n  float v_nx1 = mix(v_n01, v_n11, v_u.x);\n  return mix(v_nx0, v_nx1, v_u.y);\n}\n\nfloat f_fbm(vec2 p_pos, int p_octaves) {\n  float v_value = 0.0;\n  float v_amplitude = 1.0;\n  float v_frequency = 1.0;\n  float v_max_value = 0.0;\n  \n  for (int i = 0; i < 8; i++) {\n    if (i >= p_octaves) break;\n    v_value += v_amplitude * f_noise(p_pos * v_frequency);\n    v_max_value += v_amplitude;\n    v_amplitude *= 0.5;\n    v_frequency *= 2.0;\n  }\n  \n  return v_value / v_max_value;\n}\n\nvec2 f_stereographic_project(vec2 p_uv, float p_radius) {\n  vec2 v_centered = p_uv * 2.0 - 1.0;\n  float v_len = length(v_centered);\n  \n  if (v_len > p_radius) {\n    return p_uv;\n  }\n  \n  float v_angle = atan(v_centered.y, v_centered.x);\n  float v_r = v_len / p_radius;\n  float v_theta = v_r * PI;\n  \n  float v_new_r = tan(v_theta / 2.0) * 2.0;\n  \n  vec2 v_projected = vec2(cos(v_angle), sin(v_angle)) * v_new_r;\n  return v_projected * 0.5 + 0.5;\n}\n\nvec2 f_spherical_warp(vec2 p_uv, float p_time, float p_audio_bass, float p_audio_mid, float p_audio_treble) {\n  vec2 v_centered = p_uv * 2.0 - 1.0;\n  float v_dist = length(v_centered);\n  float v_angle = atan(v_centered.y, v_centered.x);\n  \n  float v_warp = sin(v_angle * 3.0 + p_time) * 0.3;\n  v_warp += cos(v_dist * 5.0 - p_time * 1.5) * 0.2;\n  v_warp += sin(p_time * 0.7) * p_audio_bass * 0.4;\n  v_warp += cos(p_time * 1.2) * p_audio_mid * 0.3;\n  v_warp += sin(p_time * 2.0) * p_audio_treble * 0.25;\n  \n  float v_new_dist = v_dist * (1.0 + v_warp);\n  \n  vec2 v_warped = vec2(cos(v_angle), sin(v_angle)) * v_new_dist;\n  return v_warped * 0.5 + 0.5;\n}\n\nvec2 f_fractal_bend(vec2 p_uv, float p_time, float p_depth, float p_audio_bass, float p_audio_mid, float p_audio_treble) {\n  vec2 v_pos = p_uv;\n  float v_scale = 1.0;\n  \n  for (float i = 0.0; i < 5.0; i++) {\n    if (i >= p_depth) break;\n    \n    v_pos = abs(v_pos - 0.5) + 0.5;\n    \n    float v_bend = sin(p_time * (0.5 + i * 0.3) + p_audio_bass * 2.0) * 0.15;\n    v_bend += cos(p_time * (0.7 + i * 0.2) + p_audio_mid * 1.5) * 0.1;\n    v_bend += sin(p_time * (1.1 + i * 0.4) + p_audio_treble * 2.5) * 0.12;\n    \n    v_pos += vec2(sin(v_pos.y * 10.0 + p_time), cos(v_pos.x * 10.0 + p_time)) * v_bend;\n    \n    v_scale *= 0.5;\n  }\n  \n  return v_pos;\n}\n\nvec2 f_nonlinear_warp(vec2 p_uv, float p_time, float p_distortion, float p_audio_bass, float p_audio_mid, float p_audio_treble) {\n  vec2 v_centered = p_uv * 2.0 - 1.0;\n  float v_dist = length(v_centered);\n  float v_angle = atan(v_centered.y, v_centered.x);\n  \n  float v_radial_warp = sin(v_dist * 8.0 - p_time * 2.0) * p_distortion * 0.2;\n  v_radial_warp += p_audio_bass * 0.3;\n  v_radial_warp += p_audio_mid * 0.2;\n  v_radial_warp += p_audio_treble * 0.15;\n  \n  float v_angular_warp = cos(v_angle * 4.0 + p_time) * p_distortion * 0.15;\n  v_angular_warp += sin(p_time * 1.3) * p_audio_mid * 0.2;\n  \n  float v_new_dist = v_dist * (1.0 + v_radial_warp);\n  float v_new_angle = v_angle + v_angular_warp;\n  \n  vec2 v_warped = vec2(cos(v_new_angle), sin(v_new_angle)) * v_new_dist;\n  return v_warped * 0.5 + 0.5;\n}\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord) {\n  vec2 v_uv = mm_FragNormCoord;\n  float v_aspect = FX_IMG_SIZE().x / FX_IMG_SIZE().y;\n  v_uv.x *= v_aspect;\n  \n  float v_audio_bass = IMG_NORM_PIXEL(fx_waveformFFT, vec2(0.16, 0.0)).x * fx_bass_react;\n  float v_audio_mid = IMG_NORM_PIXEL(fx_waveformFFT, vec2(0.5, 0.0)).x * fx_mid_react;\n  float v_audio_treble = IMG_NORM_PIXEL(fx_waveformFFT, vec2(0.84, 0.0)).x * fx_treble_react;\n  \n  vec2 v_warped = v_uv;\n  \n  v_warped = f_spherical_warp(v_warped, fx_anim_time, v_audio_bass, v_audio_mid, v_audio_treble);\n  \n  v_warped = f_nonlinear_warp(v_warped, fx_anim_time * 0.5, fx_distortion, v_audio_bass, v_audio_mid, v_audio_treble);\n  \n  v_warped = f_fractal_bend(v_warped, fx_anim_time * 0.3, fx_fractal_depth, v_audio_bass, v_audio_mid, v_audio_treble);\n  \n  v_warped = f_stereographic_project(v_warped, fx_proj_radius);\n  \n  v_warped.x /= v_aspect;\n  \n  v_warped = clamp(v_warped, 0.0, 1.0);\n  \n  vec4 v_color = FX_NORM_PIXEL(v_warped);\n  \n  float v_chromatic = 0.01 * (v_audio_bass + v_audio_mid * 0.5);\n  vec4 v_r = FX_NORM_PIXEL(clamp(v_warped + vec2(v_chromatic, 0.0), 0.0, 1.0));\n  vec4 v_b = FX_NORM_PIXEL(clamp(v_warped - vec2(v_chromatic, 0.0), 0.0, 1.0));\n  \n  v_color.r = v_r.r;\n  v_color.b = v_b.b;\n  \n  return v_color;\n}",
            "isPrompt": false,
            "madness": 0.5,
            "mode": "",
            "title": "Manual edition"
        }
    ],
    "index": 2
}
