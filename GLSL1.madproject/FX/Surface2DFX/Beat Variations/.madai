{
    "editions": [
        {
            "code": "/*{\n    \"DESCRIPTION\": \"Beat Split Transition with Random Variations\",\n    \"CREDIT\": \"mad\",\n    \"INPUTS\": [\n        { \"LABEL\": \"Beats\", \"NAME\": \"fx_beats\", \"TYPE\": \"float\", \"DEFAULT\": 4.0, \"MIN\": 1.0, \"MAX\": 16.0 },\n        { \"LABEL\": \"Variations\", \"NAME\": \"fx_variations\", \"TYPE\": \"float\", \"DEFAULT\": 6.0, \"MIN\": 3.0, \"MAX\": 10.0 },\n        { \"LABEL\": \"Random Seed\", \"NAME\": \"fx_seed\", \"TYPE\": \"float\", \"DEFAULT\": 1.0, \"MIN\": 0.0, \"MAX\": 100.0 }\n    ],\n    \"GENERATORS\": [\n\t\t{ \"NAME\": \"fx_bpm_position\", \"TYPE\": \"time_base\", \"PARAMS\": {\"speed\": 1, \"bpm_sync\": true} }  \n    ]\n}*/\n\nfloat fx_mod(float x, float y) {\n    return x - y * floor(x/y);\n}\n\n// Hash function for random values\nfloat fx_hash(vec2 p) {\n    p = fract(p * vec2(123.4, 789.1));\n    p += dot(p, p + 33.33);\n    return fract(p.x * p.y);\n}\n\n// Noise generator based on hash\nfloat fx_noise(vec2 p, float seed) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // Smoothstep\n    \n    float a = fx_hash(i + vec2(0.0, 0.0) + seed);\n    float b = fx_hash(i + vec2(1.0, 0.0) + seed);\n    float c = fx_hash(i + vec2(0.0, 1.0) + seed);\n    float d = fx_hash(i + vec2(1.0, 1.0) + seed);\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\n// Warp function for distortion effects\nvec2 fx_warp(vec2 uv, float amount, float seed) {\n    vec2 offset = vec2(\n        fx_noise(uv * 5.0 + 0.2, seed),\n        fx_noise(uv * 5.0 + 10.0, seed + 1.0)\n    );\n    return uv + (offset * 2.0 - 1.0) * amount;\n}\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord) {\n    vec2 uv = mm_FragNormCoord;\n    float beatPhase = fx_mod(fx_bpm_position, fx_beats);\n    \n    // Random value based on beats and seed\n    float randomSeed = floor(fx_bpm_position / fx_beats) + fx_seed;\n    float random1 = fx_hash(vec2(randomSeed, 123.45));\n    float random2 = fx_hash(vec2(randomSeed, 678.91));\n    float random3 = fx_hash(vec2(randomSeed, 246.80));\n    \n    // Select a transition type based on random and variations parameter\n    int transitionType = int(floor(random1 * fx_variations));\n    float transition = smoothstep(0.0, 0.5, beatPhase);\n    \n    // Based on the transition type, apply different effects\n    if (transitionType == 0) {\n        // Scroll from top\n        uv.y = (uv.y - 1.0 + transition);\n        uv.y = fx_mod(uv.y, 1.0);\n    } \n    else if (transitionType == 1) {\n        // Scroll from right\n        uv.x = (uv.x - 1.0 + transition);\n        uv.x = fx_mod(uv.x, 1.0);\n    }\n    else if (transitionType == 2) {\n        // Scroll from bottom\n        uv.y = (uv.y + 1.0 - transition);\n        uv.y = fx_mod(uv.y, 1.0);\n    }\n    else if (transitionType == 3) {\n        // Scroll from left\n        uv.x = (uv.x + 1.0 - transition);\n        uv.x = fx_mod(uv.x, 1.0);\n    }\n    else if (transitionType == 4) {\n        // Diamond transition\n        float dist = abs(uv.x - 0.5) + abs(uv.y - 0.5);\n        float diamondSize = transition * 1.5;\n        if (dist > diamondSize) {\n            return FX_NORM_PIXEL(vec2(fx_mod(uv.x + random2, 1.0), fx_mod(uv.y + random3, 1.0)));\n        }\n    }\n    else if (transitionType == 5) {\n        // Split into grid\n        int gridSize = 2 + int(random2 * 3.0);\n        vec2 gridUV = uv * float(gridSize);\n        vec2 cell = floor(gridUV);\n        gridUV = fract(gridUV);\n        \n        // Each cell gets a different delay\n        float cellDelay = fx_hash(cell + randomSeed);\n        float cellTransition = smoothstep(0.0, 0.5, beatPhase - cellDelay * 0.5);\n        \n        if (cellTransition < 1.0) {\n            gridUV = (gridUV - 0.5) * (1.0 / max(0.01, cellTransition)) + 0.5;\n            if (gridUV.x < 0.0 || gridUV.x > 1.0 || gridUV.y < 0.0 || gridUV.y > 1.0) {\n                // Wrapping behavior for out-of-bounds\n                gridUV = fract(gridUV);\n            }\n        }\n        uv = gridUV;\n    }\n    else if (transitionType == 6) {\n        // Spiral\n        vec2 center = vec2(0.5, 0.5);\n        vec2 toCenter = uv - center;\n        float angle = atan(toCenter.y, toCenter.x);\n        float dist = length(toCenter);\n        float newAngle = angle + transition * 10.0 * random2;\n        uv = center + dist * vec2(cos(newAngle), sin(newAngle));\n    }\n    else if (transitionType == 7) {\n        // Zoom in/out\n        vec2 center = vec2(0.5 + (random2 - 0.5) * 0.4, 0.5 + (random3 - 0.5) * 0.4);\n        uv = center + (uv - center) * (1.0 + transition * (random1 > 0.5 ? 1.0 : -0.8));\n    }\n    else if (transitionType == 8) {\n        // Warp effect\n        uv = fx_warp(uv, transition * 0.3, randomSeed);\n    }\n    else {\n        // Diagonal swipe\n        float diag = (uv.x + uv.y) * 0.5;\n        diag = (diag - 1.0 + transition);\n        if (diag < 0.0) {\n            uv = vec2(fx_mod(uv.x + random2, 1.0), fx_mod(uv.y + random3, 1.0));\n        }\n    }\n    \n    // Apply a subtle color shift based on beat phase for some transitions\n    vec4 color = FX_NORM_PIXEL(uv);\n    if (transitionType == 4 || transitionType == 6 || transitionType == 8) {\n        float colorShift = sin(beatPhase * 3.14159) * 0.05;\n        color.r = FX_NORM_PIXEL(vec2(fx_mod(uv.x + colorShift, 1.0), fx_mod(uv.y, 1.0))).r;\n        color.b = FX_NORM_PIXEL(vec2(fx_mod(uv.x - colorShift, 1.0), fx_mod(uv.y, 1.0))).b;\n    }\n    \n    return color;\n}",
            "isPrompt": false,
            "title": "original"
        }
    ],
    "index": 0,
    "modeType": ""
}
