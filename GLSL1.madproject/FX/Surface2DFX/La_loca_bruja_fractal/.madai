{
    "editions": [
        {
            "code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n// MadMapper audio uniforms\nuniform float mm_AudioAnalysisLow;\nuniform float mm_AudioAnalysisMid;\nuniform float mm_AudioAnalysisHigh;\n\n// Time and resolution\nuniform float time;\nuniform vec2 resolution;\n\n// ------------------------------------------------------------\n// Utility\n// ------------------------------------------------------------\n\n// Simple glitter noise\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(27.1, 91.7))) * 43758.5453123);\n}\n\n// Holographic prism color\nvec3 prism(float x) {\n    return 0.5 + 0.5 * cos(6.2831 * (x + vec3(0.0, 0.33, 0.66)));\n}\n\n// ------------------------------------------------------------\n// 3D spherical warp space\n// ------------------------------------------------------------\nvec3 sphereWarp(vec3 p, float t) {\n    // Audio Mid → Rotation strength\n    float rot = t * 0.3 + mm_AudioAnalysisMid * 4.0;\n\n    float c = cos(rot), s = sin(rot);\n\n    // rotation around Z\n    mat3 rotZ = mat3(\n        c, -s, 0.0,\n        s,  c, 0.0,\n        0.0, 0.0, 1.0\n    );\n    p = rotZ * p;\n\n    // Audio Low → Deformation\n    float deform = mm_AudioAnalysisLow * 0.6;\n\n    p.xy += deform * sin(p.z * 3.0 + t * 2.0);\n    p.yz += deform * sin(p.x * 2.0 + t * 1.5);\n\n    return p;\n}\n\n// ------------------------------------------------------------\n// Glitter effect from audio highs\n// ------------------------------------------------------------\nvec3 glitter(vec2 uv, float t) {\n    uv *= 40.0;\n\n    vec2 g = fract(uv);\n    float d = length(g - 0.5);\n\n    float sparkle = smoothstep(0.15, 0.0, d);\n\n    float flicker =\n        pow(abs(sin(t * 25.0 + hash(g * t) * 20.0)), 8.0);\n\n    return vec3(flicker * sparkle * mm_AudioAnalysisHigh * 2.0);\n}\n\n// ------------------------------------------------------------\n// MAIN\n// ------------------------------------------------------------\nvec4 fxColorForPixel(vec2 uv) {\n    float t = time * 0.7;\n\n    // Normalize coords\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= resolution.x / resolution.y;\n\n    // convert 2D → inside spherical surface\n    vec3 pos = vec3(p, 0.0);\n    pos.z = sqrt(max(0.0, 1.0 - dot(p, p)));\n\n    // Warp 3D space with audio\n    pos = sphereWarp(pos, t);\n\n    // Hologram shimmer\n    float holo = sin(\n        pos.x * 4.0 +\n        pos.y * 3.0 +\n        pos.z * 6.0 +\n        t * 3.0\n    );\n\n    // Glossy prism colors\n    vec3 col = prism(holo);\n\n    // Depth shading (towards center brighter)\n    float depth = smoothstep(1.2, 0.1, length(p));\n    col *= depth * (1.0 + mm_AudioAnalysisLow * 2.0);\n\n    // Add glitter from audio highs\n    col += glitter(uv, t);\n\n    return vec4(col, 1.0);\n}\n",
            "isPrompt": false,
            "madness": 0.5,
            "mode": "",
            "title": "New"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"Made with MadAI\",\n  \"DESCRIPTION\": \"Real-time 3D volumetric fractal with icy crystalline winter aesthetic and audio reactivity\",\n  \"TAGS\": \"fractal,3D,audio,winter,crystal,volumetric\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Fractal/Complexity\", \"NAME\": \"fx_complexity\", \"TYPE\": \"float\", \"DEFAULT\": 4.0, \"MIN\": 1.0, \"MAX\": 8.0, \"DESCRIPTION\": \"Fractal iteration depth\" },\n    { \"LABEL\": \"Fractal/Twist\", \"NAME\": \"fx_twist\", \"TYPE\": \"float\", \"DEFAULT\": 0.5, \"MIN\": 0.0, \"MAX\": 2.0, \"DESCRIPTION\": \"Rotation twist amount\" },\n    { \"LABEL\": \"Fractal/Scale\", \"NAME\": \"fx_fractal_scale\", \"TYPE\": \"float\", \"DEFAULT\": 1.5, \"MIN\": 0.5, \"MAX\": 3.0, \"DESCRIPTION\": \"Fractal scale factor\" },\n    { \"LABEL\": \"Camera/Depth\", \"NAME\": \"fx_depth\", \"TYPE\": \"float\", \"DEFAULT\": 3.0, \"MIN\": 1.0, \"MAX\": 8.0, \"DESCRIPTION\": \"Camera distance\" },\n    { \"LABEL\": \"Camera/Rotation\", \"NAME\": \"fx_rotation_speed\", \"TYPE\": \"float\", \"DEFAULT\": 0.3, \"MIN\": 0.0, \"MAX\": 1.0, \"DESCRIPTION\": \"Camera rotation speed\" },\n    { \"LABEL\": \"Visual/Glow\", \"NAME\": \"fx_glow_intensity\", \"TYPE\": \"float\", \"DEFAULT\": 1.2, \"MIN\": 0.0, \"MAX\": 3.0, \"DESCRIPTION\": \"Glow intensity\" },\n    { \"LABEL\": \"Visual/Density\", \"NAME\": \"fx_density\", \"TYPE\": \"float\", \"DEFAULT\": 1.0, \"MIN\": 0.3, \"MAX\": 2.0, \"DESCRIPTION\": \"Crystal density\" },\n    { \"LABEL\": \"Color/Hue Shift\", \"NAME\": \"fx_hue_shift\", \"TYPE\": \"float\", \"DEFAULT\": 0.55, \"MIN\": 0.0, \"MAX\": 1.0, \"DESCRIPTION\": \"Color hue shift\" },\n    { \"LABEL\": \"Audio/Bass React\", \"NAME\": \"fx_bass_react\", \"TYPE\": \"float\", \"DEFAULT\": 0.5, \"MIN\": 0.0, \"MAX\": 1.0, \"DESCRIPTION\": \"Bass reactivity\" },\n    { \"LABEL\": \"Audio/Treble React\", \"NAME\": \"fx_treble_react\", \"TYPE\": \"float\", \"DEFAULT\": 0.3, \"MIN\": 0.0, \"MAX\": 1.0, \"DESCRIPTION\": \"Treble reactivity\" },\n    { \"LABEL\": \"Audio/Smoothness\", \"NAME\": \"fx_audio_smooth\", \"TYPE\": \"float\", \"DEFAULT\": 0.1, \"MIN\": 0.0, \"MAX\": 0.5, \"DESCRIPTION\": \"Audio smoothing\" },\n    { \"NAME\": \"fx_waveformFFT\", \"TYPE\": \"audioFFT\", \"SIZE\": 64, \"RELEASE\": \"fx_audio_smooth\", \"ATTACK\": 0 }\n  ],\n  \"GENERATORS\": [\n    { \"NAME\": \"fx_anim_time\", \"TYPE\": \"time_base\", \"PARAMS\": {\"speed\": 0.5, \"bpm_sync\": false} }\n  ]\n}*/\n\n#ifndef PI\n#define PI 3.14159265359\n#endif\n\nvec3 f_hsv2rgb(vec3 p_hsv) {\n  vec3 v_rgb = clamp(abs(mod(p_hsv.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n  return p_hsv.z * mix(vec3(1.0), v_rgb, p_hsv.y);\n}\n\nfloat f_hash(vec3 p_pos) {\n  float v_h = dot(p_pos, vec3(127.1, 311.7, 74.7));\n  return fract(sin(v_h) * 43758.5453123);\n}\n\nfloat f_noise3d(vec3 p_pos) {\n  vec3 v_i = floor(p_pos);\n  vec3 v_f = fract(p_pos);\n  vec3 v_u = v_f * v_f * (3.0 - 2.0 * v_f);\n  \n  float v_n0 = mix(mix(mix(f_hash(v_i + vec3(0.0, 0.0, 0.0)), f_hash(v_i + vec3(1.0, 0.0, 0.0)), v_u.x),\n                        mix(f_hash(v_i + vec3(0.0, 1.0, 0.0)), f_hash(v_i + vec3(1.0, 1.0, 0.0)), v_u.x), v_u.y),\n                   mix(mix(f_hash(v_i + vec3(0.0, 0.0, 1.0)), f_hash(v_i + vec3(1.0, 0.0, 1.0)), v_u.x),\n                        mix(f_hash(v_i + vec3(0.0, 1.0, 1.0)), f_hash(v_i + vec3(1.0, 1.0, 1.0)), v_u.x), v_u.y), v_u.z);\n  return v_n0;\n}\n\nfloat f_fbm(vec3 p_pos, int p_octaves) {\n  float v_value = 0.0;\n  float v_amplitude = 1.0;\n  float v_frequency = 1.0;\n  float v_max = 0.0;\n  \n  for (int i = 0; i < 8; i++) {\n    if (i >= p_octaves) break;\n    v_value += v_amplitude * f_noise3d(p_pos * v_frequency);\n    v_max += v_amplitude;\n    v_amplitude *= 0.5;\n    v_frequency *= 2.0;\n  }\n  return v_value / v_max;\n}\n\nmat3 f_rotateX(float p_angle) {\n  float v_c = cos(p_angle);\n  float v_s = sin(p_angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, v_c, -v_s, 0.0, v_s, v_c);\n}\n\nmat3 f_rotateY(float p_angle) {\n  float v_c = cos(p_angle);\n  float v_s = sin(p_angle);\n  return mat3(v_c, 0.0, v_s, 0.0, 1.0, 0.0, -v_s, 0.0, v_c);\n}\n\nmat3 f_rotateZ(float p_angle) {\n  float v_c = cos(p_angle);\n  float v_s = sin(p_angle);\n  return mat3(v_c, -v_s, 0.0, v_s, v_c, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat f_mandelbulb(vec3 p_pos, float p_power, float p_twist, float p_scale, float p_audio_bass) {\n  vec3 v_z = p_pos;\n  float v_dr = 1.0;\n  float v_r = 0.0;\n  \n  for (int i = 0; i < 16; i++) {\n    v_r = length(v_z);\n    if (v_r > 4.0) break;\n    \n    float v_theta = atan(v_z.y, v_z.x) + p_twist * p_audio_bass;\n    float v_phi = acos(v_z.z / (v_r + 0.001));\n    \n    v_dr = pow(v_r, p_power - 1.0) * p_power * v_dr + 1.0;\n    \n    float v_rn = pow(v_r, p_power);\n    v_z = vec3(v_rn * sin(v_phi * p_power) * cos(v_theta * p_power),\n               v_rn * sin(v_phi * p_power) * sin(v_theta * p_power),\n               v_rn * cos(v_phi * p_power)) + p_pos;\n  }\n  \n  return 0.5 * log(v_r) * v_r / v_dr;\n}\n\nfloat f_fractal_distance(vec3 p_pos, float p_complexity, float p_twist, float p_scale, float p_audio_bass, float p_audio_treble) {\n  vec3 v_scaled = p_pos / p_scale;\n  float v_dist = f_mandelbulb(v_scaled, 2.0 + p_complexity * 0.3, p_twist * (1.0 + p_audio_bass * 2.0), p_scale, p_audio_bass);\n  \n  float v_fbm_val = f_fbm(p_pos * 2.0 + vec3(p_audio_treble * 5.0), int(p_complexity));\n  v_dist = mix(v_dist, v_fbm_val * 0.5, 0.3);\n  \n  return v_dist * 0.8;\n}\n\nvec4 f_raymarch(vec3 p_origin, vec3 p_direction, float p_complexity, float p_twist, float p_scale, float p_glow, float p_density, float p_audio_bass, float p_audio_treble) {\n  float v_dist = 0.0;\n  float v_total_dist = 0.0;\n  vec3 v_pos = p_origin;\n  vec4 v_color = vec4(0.0);\n  float v_transmittance = 1.0;\n  \n  for (int i = 0; i < 128; i++) {\n    v_pos = p_origin + p_direction * v_total_dist;\n    \n    float v_sdf = f_fractal_distance(v_pos, p_complexity, p_twist, p_scale, p_audio_bass, p_audio_treble);\n    v_dist = max(v_sdf, 0.01);\n    \n    if (v_dist < 0.05) {\n      float v_density_factor = exp(-v_total_dist * p_density * 0.5);\n      float v_brightness = (1.0 - abs(v_sdf)) * v_density_factor;\n      \n      vec3 v_hue = vec3(0.55 + p_audio_treble * 0.1, 0.8 - p_audio_bass * 0.3, 0.9 + p_audio_bass * 0.2);\n      vec3 v_crystal_color = f_hsv2rgb(v_hue);\n      \n      float v_glow_factor = exp(-v_total_dist * 0.3) * p_glow;\n      v_color.rgb += v_transmittance * v_crystal_color * v_brightness * v_glow_factor;\n      v_transmittance *= 0.85;\n    }\n    \n    v_total_dist += v_dist * 0.5;\n    \n    if (v_total_dist > 20.0 || v_transmittance < 0.01) break;\n  }\n  \n  v_color.a = 1.0 - v_transmittance;\n  return v_color;\n}\n\nvec4 fxColorForPixel(vec2 p_uv) {\n  vec2 v_uv = p_uv * 2.0 - 1.0;\n  float v_aspect = FX_IMG_SIZE().x / FX_IMG_SIZE().y;\n  v_uv.x *= v_aspect;\n  \n  float v_audio_bass = IMG_NORM_PIXEL(fx_waveformFFT, vec2(0.1, 0.0)).x;\n  float v_audio_mid = IMG_NORM_PIXEL(fx_waveformFFT, vec2(0.5, 0.0)).x;\n  float v_audio_treble = IMG_NORM_PIXEL(fx_waveformFFT, vec2(0.9, 0.0)).x;\n  \n  v_audio_bass = mix(v_audio_bass, v_audio_bass * fx_bass_react, 0.8);\n  v_audio_treble = mix(v_audio_treble, v_audio_treble * fx_treble_react, 0.8);\n  \n  float v_time = fx_anim_time;\n  float v_rotation_amount = v_time * fx_rotation_speed + v_audio_mid * 2.0;\n  \n  mat3 v_rot_x = f_rotateX(v_rotation_amount * 0.3 + v_audio_bass * PI);\n  mat3 v_rot_y = f_rotateY(v_rotation_amount + v_audio_treble * PI * 0.5);\n  mat3 v_rot_z = f_rotateZ(v_rotation_amount * 0.7);\n  \n  mat3 v_total_rot = v_rot_z * v_rot_y * v_rot_x;\n  \n  vec3 v_direction = normalize(vec3(v_uv, 1.0));\n  v_direction = v_total_rot * v_direction;\n  \n  float v_camera_dist = fx_depth + v_audio_bass * 1.5;\n  vec3 v_camera_pos = vec3(0.0, 0.0, -v_camera_dist);\n  v_camera_pos = v_total_rot * v_camera_pos;\n  \n  vec4 v_fractal = f_raymarch(v_camera_pos, v_direction, fx_complexity, fx_twist, fx_fractal_scale, fx_glow_intensity, fx_density, v_audio_bass, v_audio_treble);\n  \n  vec4 v_input = FX_NORM_PIXEL(p_uv);\n  \n  vec4 v_final = mix(v_input, v_fractal, v_fractal.a * 0.9);\n  v_final.rgb += v_fractal.rgb * 0.3 * (1.0 + v_audio_bass);\n  \n  return v_final;\n}",
            "isPrompt": true,
            "madness": 0.5384619832038879,
            "mode": "Faster",
            "title": "Create a real-time 3D fractal shader with an icy, crystalline winter aesthetic.\nThe fractal should look like a volumetric structure made of snow crystals or frozen nebula clouds: organic, geometric, shimmering.\nEverything should react smoothly and rhythmically to audio input.\n\nRequired features:\n\n• 3D volumetric fractal using raymarching\n• Dense, glowing crystal clusters that feel icy and alive\n• Soft winter light scattering and subtle glow\n• Fractal should move, twist or breathe with the music\n• React to audio amplitude and frequency (glow, motion, density)\n• Smooth camera motion or rotation for depth\n• Adjustable parameters: fractal complexity, twist, depth, color shift, glow\n• Colors: cold winter palette — whites, cyans, soft blues, shimmering highlights\n• Visual style: clean, modern, immersive, cinematic\n• Performance optimized for real-time visuals in MadMapper"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"Made with MadAI\",\n  \"DESCRIPTION\": \"3D holographic effect with audio reactivity - bass deforms, mids rotate, treble shimmers\",\n  \"TAGS\": \"hologram,3D,audio,glossy,sci-fi,material\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Hologram/Scale\", \"NAME\": \"fx_holo_scale\", \"TYPE\": \"float\", \"DEFAULT\": 1.0, \"MIN\": 0.5, \"MAX\": 3.0, \"DESCRIPTION\": \"Hologram size\" },\n    { \"LABEL\": \"Hologram/Layers\", \"NAME\": \"fx_holo_layers\", \"TYPE\": \"float\", \"DEFAULT\": 3.0, \"MIN\": 1.0, \"MAX\": 8.0, \"DESCRIPTION\": \"Number of layers\" },\n    { \"LABEL\": \"Hologram/Depth\", \"NAME\": \"fx_holo_depth\", \"TYPE\": \"float\", \"DEFAULT\": 1.5, \"MIN\": 0.5, \"MAX\": 3.0, \"DESCRIPTION\": \"Depth intensity\" },\n    { \"LABEL\": \"Hologram/Glossiness\", \"NAME\": \"fx_glossiness\", \"TYPE\": \"float\", \"DEFAULT\": 0.8, \"MIN\": 0.0, \"MAX\": 1.0, \"DESCRIPTION\": \"Glossy reflection\" },\n    { \"LABEL\": \"Hologram/Opacity\", \"NAME\": \"fx_opacity\", \"TYPE\": \"float\", \"DEFAULT\": 0.7, \"MIN\": 0.0, \"MAX\": 1.0, \"DESCRIPTION\": \"Overall opacity\" },\n    { \"LABEL\": \"Color/Primary\", \"NAME\": \"fx_color_primary\", \"TYPE\": \"color\", \"DEFAULT\": [0.0, 1.0, 0.8, 1.0], \"FLAGS\": [\"no_alpha\"], \"DESCRIPTION\": \"Primary holo color\" },\n    { \"LABEL\": \"Color/Secondary\", \"NAME\": \"fx_color_secondary\", \"TYPE\": \"color\", \"DEFAULT\": [0.2, 0.8, 1.0, 1.0], \"FLAGS\": [\"no_alpha\"], \"DESCRIPTION\": \"Secondary holo color\" },\n    { \"LABEL\": \"Color/Accent\", \"NAME\": \"fx_color_accent\", \"TYPE\": \"color\", \"DEFAULT\": [1.0, 0.4, 0.8, 1.0], \"FLAGS\": [\"no_alpha\"], \"DESCRIPTION\": \"Accent shimmer color\" },\n    { \"LABEL\": \"Audio/Bass Strength\", \"NAME\": \"fx_bass_strength\", \"TYPE\": \"float\", \"DEFAULT\": 0.6, \"MIN\": 0.0, \"MAX\": 1.0, \"DESCRIPTION\": \"Bass deformation\" },\n    { \"LABEL\": \"Audio/Mid Strength\", \"NAME\": \"fx_mid_strength\", \"TYPE\": \"float\", \"DEFAULT\": 0.5, \"MIN\": 0.0, \"MAX\": 1.0, \"DESCRIPTION\": \"Mid rotation\" },\n    { \"LABEL\": \"Audio/Treble Strength\", \"NAME\": \"fx_treble_strength\", \"TYPE\": \"float\", \"DEFAULT\": 0.8, \"MIN\": 0.0, \"MAX\": 1.0, \"DESCRIPTION\": \"Treble shimmer\" },\n    { \"LABEL\": \"Audio/Smoothness\", \"NAME\": \"fx_audio_smooth\", \"TYPE\": \"float\", \"DEFAULT\": 0.15, \"MIN\": 0.0, \"MAX\": 0.5, \"DESCRIPTION\": \"Audio smoothing\" },\n    { \"NAME\": \"fx_waveformFFT\", \"TYPE\": \"audioFFT\", \"SIZE\": 64, \"RELEASE\": \"fx_audio_smooth\", \"ATTACK\": 0 }\n  ],\n  \"GENERATORS\": [\n    { \"NAME\": \"fx_time_base\", \"TYPE\": \"time_base\", \"PARAMS\": {\"speed\": 1.0, \"bpm_sync\": false} }\n  ]\n}*/\n\n#ifndef PI\n#define PI 3.14159265359\n#endif\n\nfloat f_hash(vec3 p_pos) {\n  float v_h = dot(p_pos, vec3(127.1, 311.7, 74.7));\n  return fract(sin(v_h) * 43758.5453123);\n}\n\nfloat f_noise3d(vec3 p_pos) {\n  vec3 v_i = floor(p_pos);\n  vec3 v_f = fract(p_pos);\n  vec3 v_u = v_f * v_f * (3.0 - 2.0 * v_f);\n  \n  float v_n0 = mix(mix(mix(f_hash(v_i + vec3(0.0, 0.0, 0.0)), f_hash(v_i + vec3(1.0, 0.0, 0.0)), v_u.x),\n                        mix(f_hash(v_i + vec3(0.0, 1.0, 0.0)), f_hash(v_i + vec3(1.0, 1.0, 0.0)), v_u.x), v_u.y),\n                   mix(mix(f_hash(v_i + vec3(0.0, 0.0, 1.0)), f_hash(v_i + vec3(1.0, 0.0, 1.0)), v_u.x),\n                        mix(f_hash(v_i + vec3(0.0, 1.0, 1.0)), f_hash(v_i + vec3(1.0, 1.0, 1.0)), v_u.x), v_u.y), v_u.z);\n  return v_n0;\n}\n\nfloat f_fbm(vec3 p_pos, int p_octaves) {\n  float v_value = 0.0;\n  float v_amplitude = 1.0;\n  float v_frequency = 1.0;\n  float v_max = 0.0;\n  \n  for (int i = 0; i < 8; i++) {\n    if (i >= p_octaves) break;\n    v_value += v_amplitude * f_noise3d(p_pos * v_frequency);\n    v_max += v_amplitude;\n    v_amplitude *= 0.5;\n    v_frequency *= 2.0;\n  }\n  return v_value / v_max;\n}\n\nvec3 f_spherical_distortion(vec3 p_pos, float p_bass, float p_mid) {\n  float v_r = length(p_pos);\n  float v_bass_distort = 1.0 + p_bass * 0.5;\n  float v_theta = atan(p_pos.y, p_pos.x) + p_mid * PI;\n  float v_phi = acos(p_pos.z / (v_r + 0.001));\n  \n  vec3 v_distorted = vec3(\n    v_r * v_bass_distort * sin(v_phi) * cos(v_theta),\n    v_r * v_bass_distort * sin(v_phi) * sin(v_theta),\n    v_r * v_bass_distort * cos(v_phi)\n  );\n  \n  return v_distorted;\n}\n\nfloat f_hologram_sdf(vec3 p_pos, float p_bass, float p_mid, float p_scale) {\n  vec3 v_distorted = f_spherical_distortion(p_pos, p_bass, p_mid);\n  float v_sphere = length(v_distorted) - p_scale;\n  \n  float v_wave = sin(v_distorted.x * 8.0 + fx_time_base * 2.0) * 0.1;\n  v_wave += sin(v_distorted.y * 8.0 + fx_time_base * 2.5) * 0.1;\n  v_wave += sin(v_distorted.z * 8.0 + fx_time_base * 2.2) * 0.1;\n  \n  float v_noise = f_fbm(v_distorted * 3.0 + vec3(fx_time_base), 3) * 0.15;\n  \n  return v_sphere + v_wave + v_noise;\n}\n\nvec3 f_hologram_normal(vec3 p_pos, float p_bass, float p_mid, float p_scale) {\n  float v_eps = 0.001;\n  float v_dx = f_hologram_sdf(p_pos + vec3(v_eps, 0.0, 0.0), p_bass, p_mid, p_scale) - f_hologram_sdf(p_pos - vec3(v_eps, 0.0, 0.0), p_bass, p_mid, p_scale);\n  float v_dy = f_hologram_sdf(p_pos + vec3(0.0, v_eps, 0.0), p_bass, p_mid, p_scale) - f_hologram_sdf(p_pos - vec3(0.0, v_eps, 0.0), p_bass, p_mid, p_scale);\n  float v_dz = f_hologram_sdf(p_pos + vec3(0.0, 0.0, v_eps), p_bass, p_mid, p_scale) - f_hologram_sdf(p_pos - vec3(0.0, 0.0, v_eps), p_bass, p_mid, p_scale);\n  return normalize(vec3(v_dx, v_dy, v_dz));\n}\n\nvec4 f_raymarch_hologram(vec3 p_origin, vec3 p_dir, float p_bass, float p_mid, float p_treble, float p_scale, float p_depth, float p_glossiness) {\n  float v_t = 0.0;\n  vec3 v_pos = p_origin;\n  vec4 v_result = vec4(0.0);\n  \n  for (int i = 0; i < 64; i++) {\n    v_pos = p_origin + p_dir * v_t;\n    float v_dist = f_hologram_sdf(v_pos, p_bass, p_mid, p_scale);\n    \n    if (abs(v_dist) < 0.01) {\n      vec3 v_normal = f_hologram_normal(v_pos, p_bass, p_mid, p_scale);\n      vec3 v_view_dir = -p_dir;\n      \n      float v_fresnel = pow(1.0 - abs(dot(v_normal, v_view_dir)), 2.0);\n      float v_diffuse = max(0.0, dot(v_normal, normalize(vec3(1.0, 1.0, 1.0)))) * 0.5 + 0.5;\n      \n      vec3 v_reflect = reflect(p_dir, v_normal);\n      float v_spec = pow(max(0.0, dot(v_reflect, v_view_dir)), 32.0 * p_glossiness) * p_glossiness;\n      \n      float v_shimmer = sin(v_pos.x * 20.0 + fx_time_base * 5.0) * 0.5 + 0.5;\n      v_shimmer *= sin(v_pos.y * 20.0 + fx_time_base * 5.5) * 0.5 + 0.5;\n      v_shimmer *= p_treble;\n      \n      vec3 v_base_color = mix(fx_color_primary.rgb, fx_color_secondary.rgb, 0.5 + 0.5 * sin(fx_time_base + length(v_pos)));\n      vec3 v_accent_color = fx_color_accent.rgb * v_shimmer * 2.0;\n      \n      v_result.rgb = v_base_color * (v_diffuse + v_fresnel * 0.5) + v_spec * vec3(1.0) + v_accent_color;\n      v_result.a = 1.0;\n      break;\n    }\n    \n    v_t += max(v_dist * 0.5, 0.02);\n    \n    if (v_t > 10.0) break;\n  }\n  \n  return v_result;\n}\n\nvec4 fxColorForPixel(vec2 p_uv) {\n  vec2 v_uv = p_uv * 2.0 - 1.0;\n  float v_aspect = FX_IMG_SIZE().x / FX_IMG_SIZE().y;\n  v_uv.x *= v_aspect;\n  \n  float v_bass = IMG_NORM_PIXEL(fx_waveformFFT, vec2(0.05, 0.0)).x;\n  float v_mid = IMG_NORM_PIXEL(fx_waveformFFT, vec2(0.5, 0.0)).x;\n  float v_treble = IMG_NORM_PIXEL(fx_waveformFFT, vec2(0.95, 0.0)).x;\n  \n  v_bass *= fx_bass_strength;\n  v_mid *= fx_mid_strength;\n  v_treble *= fx_treble_strength;\n  \n  vec3 v_ray_dir = normalize(vec3(v_uv, 1.5));\n  vec3 v_ray_origin = vec3(0.0, 0.0, -3.0);\n  \n  v_ray_origin.z -= v_bass * fx_holo_depth * 0.5;\n  v_ray_origin.x += sin(fx_time_base + v_mid * PI) * 0.5;\n  v_ray_origin.y += cos(fx_time_base + v_mid * PI) * 0.5;\n  \n  vec4 v_hologram = f_raymarch_hologram(v_ray_origin, v_ray_dir, v_bass, v_mid, v_treble, fx_holo_scale, fx_holo_depth, fx_glossiness);\n  \n  vec4 v_input = FX_NORM_PIXEL(p_uv);\n  \n  vec3 v_background = mix(v_input.rgb, vec3(0.05, 0.1, 0.15), 0.7);\n  \n  float v_glow = exp(-length(v_uv) * 0.5) * 0.3;\n  v_background += vec3(0.0, 0.3, 0.4) * v_glow;\n  \n  vec4 v_final = vec4(mix(v_background, v_hologram.rgb, v_hologram.a * fx_opacity), 1.0);\n  \n  float v_scan = sin(p_uv.y * 50.0 + fx_time_base * 10.0) * 0.05 + 0.95;\n  v_final.rgb *= v_scan;\n  \n  v_final.rgb += vec3(0.0, 0.2, 0.3) * v_treble * 0.5;\n  \n  return v_final;\n}",
            "isPrompt": true,
            "madness": 0.5384619832038879,
            "mode": "Faster",
            "title": "Create a MadMapper Material Shader that is always visible and renders a 3D holographic effect. Use time and spherical distortion to create depth and a glossy hologram look. Make the shader react to audio: bass should deform the shape, mid frequencies should rotate the space, and high frequencies should add glitter or shimmer highlights. Do not use any mouse input. The shader must run as a Material Shader in MadMapper and must always output visible colors. Use only the standard uniforms: time, resolution, mm_FragNormCoord, and the audio analysis values. Output valid GLSL ES fragment shader code that works directly inside the Material Shader editor."
        }
    ],
    "index": 2
}
