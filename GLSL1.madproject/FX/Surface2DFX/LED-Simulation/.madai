{
    "editions": [
        {
            "code": "/*\n\tAvailable uniforms:\n\n\t\t// mm_ModulationColor contains red, green, blue levels & surface opacity in alpha\n\t\t// The multiplication in the fragment shader is done by MadMapper, so you shouldn't need that\n\t\tuniform vec4 mm_ModulationColor;\n\n\t\t// Blend Mode, see possible values in Definitions below. This is handled by default by MadMapper so you should need it\n\t\tuniform int mm_BlendMode;\n\n\t\t// Used to know if we're rendering to the preview or to an output fullscreen / desktop window / syphon-spout-NDI\n\t\tuniform bool mm_IsRenderingPreview;\n\n\t\t// The index of the surface in the project (not recommended to use that)\n\t\tuniform int mm_SurfaceIndex;\n\n\tAvailable inputs:\n\n\t\t// The normalized texture coordinate for this pixel. Should be accessed with \"vec4 FX_NORM_PIXEL(vec2 uv)\"\n\t\tin vec2 mm_FragNormCoord;\n\n\t    // Normalized position of this vertex in the surface output geometry (independent of input rectangle)\n\t\tin vec2 mm_SurfaceCoord;\n\n\t\t// Alpha of this point generated from surface / mask feathering. This is automatically handled by MadMapper and\n\t\t// should not be used in an FX\n\t\tin float mm_Alpha;\n\n\n\tMain Fragment Shader calls fxColorForPixel(...) and then apply modulation color and transparency (feathering / masking),\n\tthen might adjust color depending on blending mode / highlight selection...\n\n*/\n\n/*{\n    \"CREDIT\": \"MadTeam\",\n    \"TAGS\": [\"graphics\"],\n    \"VSN\": 1.0,\n    \"DESCRIPTION\": \"Describe your FX here\",\n    \"MEDIA\": {\n        \"REQUIRES_TEXTURE\": false,\n        \"GL_TEXTURE_MIN_FILTER\": \"LINEAR\",\n        \"GL_TEXTURE_MAG_FILTER\": \"LINEAR\",\n        \"GL_TEXTURE_WRAP\": \"CLAMP_TO_EDGE\",\n    },\n    \"INPUTS\": [\n\t\t{ \"LABEL\": \"Width\", \"NAME\": \"fx_grid_width\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n\t\t{ \"LABEL\": \"Height\", \"NAME\": \"fx_grid_height\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n\t\t{ \"LABEL\": \"LED Size\", \"NAME\": \"fx_led_size\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n\t\t{ \"LABEL\": \"Feathering\", \"NAME\": \"fx_feathering\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    ],\n    \"GENERATORS\": [\n        {\"NAME\": \"fx_time\", \"TYPE\": \"time_base\", \"PARAMS\": {\"speed\": \"fx_speed\", \"speed_curve\": 2, \"link_speed_to_global_bpm\":true}},\n    ]\n}*/\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n\tfloat squareWidth = 1.0 / fx_grid_width;\n\tfloat squareHeight = 1.0 / fx_grid_height;\n\tfloat squareHNum = floor(mm_SurfaceCoord.x / squareWidth);\n\tfloat squareVNum = floor(mm_SurfaceCoord.y / squareHeight);\n\tvec2 squareCenter = vec2((0.5+squareHNum) * squareWidth, (0.5+squareVNum) * squareHeight);\n\n\t// Compute luma\n\tfloat dist = distance(squareCenter,mm_SurfaceCoord);\n\tfloat maxDist = min(squareWidth,squareHeight) * fx_led_size;\n\tfloat luma = 1 - dist/maxDist;\n\tif (luma > 0) {\n\t\tif (luma > fx_feathering) {\n\t\t\tluma = 1;\n\t\t} else {\n\t\t\tluma = 1 - (fx_feathering-luma)/fx_feathering; \n\t\t\tluma *= luma;\n\t\t}\n\t}\n\t\n\n\tvec2 centerUv = (mm_TextureMatrix*vec4(mm_SurfaceCoord,0,1)).xy;\n\n    vec4 color = FX_NORM_PIXEL(centerUv);\n\tcolor.rgb *= luma;\n\treturn color;\n}\n",
            "isPrompt": false,
            "madness": 0.5,
            "mode": "",
            "title": "Original"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"MadTeam\",\n  \"DESCRIPTION\": \"LED Grid with RGB chromatic aberration\",\n  \"TAGS\": \"graphics,led,rgb\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Grid/Width\", \"NAME\": \"fx_grid_width\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"Grid/Height\", \"NAME\": \"fx_grid_height\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"LED/Size\", \"NAME\": \"fx_led_size\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"LED/Feathering\", \"NAME\": \"fx_feathering\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"RGB/Separation\", \"NAME\": \"fx_rgb_separation\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 0.1, \"DEFAULT\": 0.02 },\n    { \"LABEL\": \"RGB/Intensity\", \"NAME\": \"fx_rgb_intensity\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 }\n  ]\n}*/\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n  float v_square_width = 1.0 / float(fx_grid_width);\n  float v_square_height = 1.0 / float(fx_grid_height);\n  float v_square_h_num = floor(mm_FragNormCoord.x / v_square_width);\n  float v_square_v_num = floor(mm_FragNormCoord.y / v_square_height);\n  vec2 v_square_center = vec2((0.5 + v_square_h_num) * v_square_width, (0.5 + v_square_v_num) * v_square_height);\n\n  float v_dist = distance(v_square_center, mm_FragNormCoord);\n  float v_max_dist = min(v_square_width, v_square_height) * fx_led_size * 0.5;\n  float v_luma = 1.0 - v_dist / v_max_dist;\n  \n  if (v_luma <= 0.0) {\n    return vec4(0.0);\n  }\n  \n  if (v_luma > fx_feathering) {\n    v_luma = 1.0;\n  } else {\n    v_luma = 1.0 - (fx_feathering - v_luma) / fx_feathering; \n    v_luma *= v_luma;\n  }\n\n  vec2 v_local_pos = (mm_FragNormCoord - v_square_center) / (v_max_dist * 2.0);\n  \n  vec2 v_red_offset = vec2(-fx_rgb_separation, 0.0);\n  vec2 v_green_offset = vec2(0.0, 0.0);\n  vec2 v_blue_offset = vec2(fx_rgb_separation, 0.0);\n  \n  vec2 v_base_uv = v_square_center;\n  \n  float v_red = FX_NORM_PIXEL(v_base_uv + v_red_offset).r;\n  float v_green = FX_NORM_PIXEL(v_base_uv + v_green_offset).g;\n  float v_blue = FX_NORM_PIXEL(v_base_uv + v_blue_offset).b;\n  \n  vec3 v_rgb_color = vec3(v_red, v_green, v_blue) * fx_rgb_intensity;\n  \n  vec4 v_final_color = vec4(v_rgb_color * v_luma, 1.0);\n  \n  return v_final_color;\n}",
            "isPrompt": true,
            "madness": 0.5,
            "mode": "Higher quality",
            "title": "ajoute et petite abération cromatique dans chaque célule comme si il s'agissai d'un écran led RGB\n"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"MadTeam\",\n  \"DESCRIPTION\": \"LED Grid with RGB chromatic aberration\",\n  \"TAGS\": \"graphics,led,rgb\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Grid/Width\", \"NAME\": \"fx_grid_width\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"Grid/Height\", \"NAME\": \"fx_grid_height\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"LED/Size\", \"NAME\": \"fx_led_size\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"LED/Feathering\", \"NAME\": \"fx_feathering\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"RGB/Red X\", \"NAME\": \"fx_red_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": -0.02 },\n    { \"LABEL\": \"RGB/Red Y\", \"NAME\": \"fx_red_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green X\", \"NAME\": \"fx_green_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green Y\", \"NAME\": \"fx_green_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Blue X\", \"NAME\": \"fx_blue_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.02 },\n    { \"LABEL\": \"RGB/Blue Y\", \"NAME\": \"fx_blue_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Intensity\", \"NAME\": \"fx_rgb_intensity\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 }\n  ]\n}*/\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n  float v_square_width = 1.0 / float(fx_grid_width);\n  float v_square_height = 1.0 / float(fx_grid_height);\n  float v_square_h_num = floor(mm_FragNormCoord.x / v_square_width);\n  float v_square_v_num = floor(mm_FragNormCoord.y / v_square_height);\n  vec2 v_square_center = vec2((0.5 + v_square_h_num) * v_square_width, (0.5 + v_square_v_num) * v_square_height);\n\n  float v_dist = distance(v_square_center, mm_FragNormCoord);\n  float v_max_dist = min(v_square_width, v_square_height) * fx_led_size * 0.5;\n  float v_luma = 1.0 - v_dist / v_max_dist;\n  \n  if (v_luma <= 0.0) {\n    return vec4(0.0);\n  }\n  \n  if (v_luma > fx_feathering) {\n    v_luma = 1.0;\n  } else {\n    v_luma = 1.0 - (fx_feathering - v_luma) / fx_feathering; \n    v_luma *= v_luma;\n  }\n  \n  vec2 v_red_offset = vec2(fx_red_x, fx_red_y);\n  vec2 v_green_offset = vec2(fx_green_x, fx_green_y);\n  vec2 v_blue_offset = vec2(fx_blue_x, fx_blue_y);\n  \n  vec2 v_base_uv = v_square_center;\n  \n  float v_red = FX_NORM_PIXEL(v_base_uv + v_red_offset).r;\n  float v_green = FX_NORM_PIXEL(v_base_uv + v_green_offset).g;\n  float v_blue = FX_NORM_PIXEL(v_base_uv + v_blue_offset).b;\n  \n  vec3 v_rgb_color = vec3(v_red, v_green, v_blue) * fx_rgb_intensity;\n  \n  vec4 v_final_color = vec4(v_rgb_color * v_luma, 1.0);\n  \n  return v_final_color;\n}",
            "isPrompt": true,
            "madness": 0.5,
            "mode": "Higher quality",
            "title": "ajoute des parametre sur l'abération chromatique.\n"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"MadTeam\",\n  \"DESCRIPTION\": \"LED Grid with RGB sub-pixels\",\n  \"TAGS\": \"graphics,led,rgb\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Grid/Width\", \"NAME\": \"fx_grid_width\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"Grid/Height\", \"NAME\": \"fx_grid_height\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"LED/Size\", \"NAME\": \"fx_led_size\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"LED/Gap\", \"NAME\": \"fx_led_gap\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 0.5, \"DEFAULT\": 0.1 },\n    { \"LABEL\": \"RGB/Red X\", \"NAME\": \"fx_red_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": -0.02 },\n    { \"LABEL\": \"RGB/Red Y\", \"NAME\": \"fx_red_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green X\", \"NAME\": \"fx_green_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green Y\", \"NAME\": \"fx_green_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Blue X\", \"NAME\": \"fx_blue_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.02 },\n    { \"LABEL\": \"RGB/Blue Y\", \"NAME\": \"fx_blue_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Intensity\", \"NAME\": \"fx_rgb_intensity\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 }\n  ]\n}*/\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n  float v_square_width = 1.0 / float(fx_grid_width);\n  float v_square_height = 1.0 / float(fx_grid_height);\n  float v_square_h_num = floor(mm_FragNormCoord.x / v_square_width);\n  float v_square_v_num = floor(mm_FragNormCoord.y / v_square_height);\n  vec2 v_square_center = vec2((0.5 + v_square_h_num) * v_square_width, (0.5 + v_square_v_num) * v_square_height);\n  \n  vec2 v_local_pos = (mm_FragNormCoord - v_square_center) / vec2(v_square_width, v_square_height);\n  \n  float v_led_width = fx_led_size * 0.5;\n  float v_led_height = fx_led_size * 0.5;\n  \n  if (abs(v_local_pos.x) > v_led_width || abs(v_local_pos.y) > v_led_height) {\n    return vec4(0.0);\n  }\n  \n  float v_sub_pixel_width = v_led_width / 3.0;\n  float v_gap_width = fx_led_gap * v_sub_pixel_width;\n  \n  vec2 v_red_offset = vec2(fx_red_x, fx_red_y);\n  vec2 v_green_offset = vec2(fx_green_x, fx_green_y);\n  vec2 v_blue_offset = vec2(fx_blue_x, fx_blue_y);\n  \n  vec2 v_base_uv = v_square_center;\n  \n  float v_red = FX_NORM_PIXEL(v_base_uv + v_red_offset).r;\n  float v_green = FX_NORM_PIXEL(v_base_uv + v_green_offset).g;\n  float v_blue = FX_NORM_PIXEL(v_base_uv + v_blue_offset).b;\n  \n  vec3 v_rgb_color = vec3(v_red, v_green, v_blue) * fx_rgb_intensity;\n  \n  float v_x_pos = v_local_pos.x + v_led_width;\n  float v_normalized_x = v_x_pos / (2.0 * v_led_width);\n  \n  vec3 v_final_rgb = vec3(0.0);\n  \n  if (v_normalized_x < 0.333) {\n    float v_sub_x = v_normalized_x * 3.0;\n    if (v_sub_x > fx_led_gap && v_sub_x < 1.0 - fx_led_gap) {\n      v_final_rgb = vec3(v_rgb_color.r, 0.0, 0.0);\n    }\n  } else if (v_normalized_x < 0.666) {\n    float v_sub_x = (v_normalized_x - 0.333) * 3.0;\n    if (v_sub_x > fx_led_gap && v_sub_x < 1.0 - fx_led_gap) {\n      v_final_rgb = vec3(0.0, v_rgb_color.g, 0.0);\n    }\n  } else {\n    float v_sub_x = (v_normalized_x - 0.666) * 3.0;\n    if (v_sub_x > fx_led_gap && v_sub_x < 1.0 - fx_led_gap) {\n      v_final_rgb = vec3(0.0, 0.0, v_rgb_color.b);\n    }\n  }\n  \n  return vec4(v_final_rgb, 1.0);\n}",
            "isPrompt": true,
            "madness": 0.5,
            "mode": "Higher quality",
            "title": "donnes au led un aspect plus carré avec trois parties , rouge, vert et bleu , comme un écran LED\n\n"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"MadTeam\",\n  \"DESCRIPTION\": \"LED Grid with RGB sub-pixels\",\n  \"TAGS\": \"graphics,led,rgb\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Grid/Width\", \"NAME\": \"fx_grid_width\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"Grid/Height\", \"NAME\": \"fx_grid_height\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"LED/Size\", \"NAME\": \"fx_led_size\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"LED/Feather\", \"NAME\": \"fx_led_feather\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 0.5, \"DEFAULT\": 0.1 },\n    { \"LABEL\": \"RGB/Red X\", \"NAME\": \"fx_red_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": -0.02 },\n    { \"LABEL\": \"RGB/Red Y\", \"NAME\": \"fx_red_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green X\", \"NAME\": \"fx_green_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green Y\", \"NAME\": \"fx_green_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Blue X\", \"NAME\": \"fx_blue_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.02 },\n    { \"LABEL\": \"RGB/Blue Y\", \"NAME\": \"fx_blue_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Intensity\", \"NAME\": \"fx_rgb_intensity\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 }\n  ]\n}*/\n\nfloat f_smoothstep_square(vec2 p_pos, float p_size, float p_feather)\n{\n  vec2 v_d = abs(p_pos) - vec2(p_size);\n  float v_dist = length(max(v_d, 0.0)) + min(max(v_d.x, v_d.y), 0.0);\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n  float v_square_width = 1.0 / float(fx_grid_width);\n  float v_square_height = 1.0 / float(fx_grid_height);\n  float v_square_h_num = floor(mm_FragNormCoord.x / v_square_width);\n  float v_square_v_num = floor(mm_FragNormCoord.y / v_square_height);\n  vec2 v_square_center = vec2((0.5 + v_square_h_num) * v_square_width, (0.5 + v_square_v_num) * v_square_height);\n  \n  vec2 v_local_pos = (mm_FragNormCoord - v_square_center) / vec2(v_square_width, v_square_height);\n  \n  float v_led_size = fx_led_size * 0.5;\n  float v_feather = fx_led_feather;\n  \n  vec2 v_red_offset = vec2(fx_red_x, fx_red_y);\n  vec2 v_green_offset = vec2(fx_green_x, fx_green_y);\n  vec2 v_blue_offset = vec2(fx_blue_x, fx_blue_y);\n  \n  vec2 v_base_uv = v_square_center;\n  \n  float v_red_value = FX_NORM_PIXEL(v_base_uv + v_red_offset).r;\n  float v_green_value = FX_NORM_PIXEL(v_base_uv + v_green_offset).g;\n  float v_blue_value = FX_NORM_PIXEL(v_base_uv + v_blue_offset).b;\n  \n  vec2 v_red_pos = v_local_pos - v_red_offset / vec2(v_square_width, v_square_height);\n  vec2 v_green_pos = v_local_pos - v_green_offset / vec2(v_square_width, v_square_height);\n  vec2 v_blue_pos = v_local_pos - v_blue_offset / vec2(v_square_width, v_square_height);\n  \n  float v_red_mask = f_smoothstep_square(v_red_pos, v_led_size, v_feather);\n  float v_green_mask = f_smoothstep_square(v_green_pos, v_led_size, v_feather);\n  float v_blue_mask = f_smoothstep_square(v_blue_pos, v_led_size, v_feather);\n  \n  vec3 v_final_color = vec3(0.0);\n  v_final_color.r = v_red_value * v_red_mask * fx_rgb_intensity;\n  v_final_color.g = v_green_value * v_green_mask * fx_rgb_intensity;\n  v_final_color.b = v_blue_value * v_blue_mask * fx_rgb_intensity;\n  \n  return vec4(v_final_color, 1.0);\n}",
            "isPrompt": true,
            "madness": 0.5,
            "mode": "Higher quality",
            "title": "fait en sorte que les carré RGB se superposent de sorte à faire du blanc, ajoute comme parametre le décalage de ces carré les un par raport aux autres et ajoute un feathering en bordure d echaque led\n"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"MadTeam\",\n  \"DESCRIPTION\": \"LED Grid with RGB sub-pixels\",\n  \"TAGS\": \"graphics,led,rgb\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Grid/Width\", \"NAME\": \"fx_grid_width\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"Grid/Height\", \"NAME\": \"fx_grid_height\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"LED/Size\", \"NAME\": \"fx_led_size\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"LED/Feather\", \"NAME\": \"fx_led_feather\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 0.5, \"DEFAULT\": 0.1 },\n    { \"LABEL\": \"RGB/Red X\", \"NAME\": \"fx_red_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": -0.02 },\n    { \"LABEL\": \"RGB/Red Y\", \"NAME\": \"fx_red_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green X\", \"NAME\": \"fx_green_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green Y\", \"NAME\": \"fx_green_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Blue X\", \"NAME\": \"fx_blue_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.02 },\n    { \"LABEL\": \"RGB/Blue Y\", \"NAME\": \"fx_blue_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Intensity\", \"NAME\": \"fx_rgb_intensity\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 }\n  ]\n}*/\n\nfloat f_smoothstep_square(vec2 p_pos, float p_size, float p_feather)\n{\n  vec2 v_d = abs(p_pos) - vec2(p_size);\n  float v_dist = length(max(v_d, 0.0)) + min(max(v_d.x, v_d.y), 0.0);\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n  float v_square_width = 1.0 / float(fx_grid_width);\n  float v_square_height = 1.0 / float(fx_grid_height);\n  float v_square_h_num = floor(mm_FragNormCoord.x / v_square_width);\n  float v_square_v_num = floor(mm_FragNormCoord.y / v_square_height);\n  vec2 v_square_center = vec2((0.5 + v_square_h_num) * v_square_width, (0.5 + v_square_v_num) * v_square_height);\n  \n  vec2 v_local_pos = (mm_FragNormCoord - v_square_center) / vec2(v_square_width, v_square_height);\n  \n  float v_led_size = fx_led_size * 0.5;\n  float v_feather = fx_led_feather;\n  \n  vec2 v_red_offset = vec2(fx_red_x, fx_red_y);\n  vec2 v_green_offset = vec2(fx_green_x, fx_green_y);\n  vec2 v_blue_offset = vec2(fx_blue_x, fx_blue_y);\n  \n  vec2 v_base_uv = v_square_center;\n  vec4 v_original_color = FX_NORM_PIXEL(v_base_uv);\n  \n  vec2 v_red_pos = v_local_pos - v_red_offset / vec2(v_square_width, v_square_height);\n  vec2 v_green_pos = v_local_pos - v_green_offset / vec2(v_square_width, v_square_height);\n  vec2 v_blue_pos = v_local_pos - v_blue_offset / vec2(v_square_width, v_square_height);\n  \n  float v_red_mask = f_smoothstep_square(v_red_pos, v_led_size, v_feather);\n  float v_green_mask = f_smoothstep_square(v_green_pos, v_led_size, v_feather);\n  float v_blue_mask = f_smoothstep_square(v_blue_pos, v_led_size, v_feather);\n  \n  vec3 v_final_color = vec3(0.0);\n  v_final_color.r = v_original_color.r * v_red_mask * fx_rgb_intensity;\n  v_final_color.g = v_original_color.g * v_green_mask * fx_rgb_intensity;\n  v_final_color.b = v_original_color.b * v_blue_mask * fx_rgb_intensity;\n  \n  return vec4(v_final_color, 1.0);\n}",
            "isPrompt": true,
            "madness": 0.5,
            "mode": "Higher quality",
            "title": "actuelement quand les trois se superposent, ça fait du vert, il faut que le Rouge, le vert et le bleu fassent du blanc quand les couleurs s'additionnent\n"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"MadTeam\",\n  \"DESCRIPTION\": \"LED Grid with RGB sub-pixels\",\n  \"TAGS\": \"graphics,led,rgb\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Grid/Width\", \"NAME\": \"fx_grid_width\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"Grid/Height\", \"NAME\": \"fx_grid_height\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"LED/Size\", \"NAME\": \"fx_led_size\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"LED/Feather\", \"NAME\": \"fx_led_feather\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 0.5, \"DEFAULT\": 0.1 },\n    { \"LABEL\": \"RGB/Red X\", \"NAME\": \"fx_red_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": -0.02 },\n    { \"LABEL\": \"RGB/Red Y\", \"NAME\": \"fx_red_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green X\", \"NAME\": \"fx_green_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green Y\", \"NAME\": \"fx_green_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Blue X\", \"NAME\": \"fx_blue_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.02 },\n    { \"LABEL\": \"RGB/Blue Y\", \"NAME\": \"fx_blue_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Intensity\", \"NAME\": \"fx_rgb_intensity\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 }\n  ]\n}*/\n\nfloat f_smoothstep_square(vec2 p_pos, float p_size, float p_feather)\n{\n  vec2 v_d = abs(p_pos) - vec2(p_size);\n  float v_dist = length(max(v_d, 0.0)) + min(max(v_d.x, v_d.y), 0.0);\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n  float v_square_width = 1.0 / float(fx_grid_width);\n  float v_square_height = 1.0 / float(fx_grid_height);\n  float v_square_h_num = floor(mm_FragNormCoord.x / v_square_width);\n  float v_square_v_num = floor(mm_FragNormCoord.y / v_square_height);\n  vec2 v_square_center = vec2((0.5 + v_square_h_num) * v_square_width, (0.5 + v_square_v_num) * v_square_height);\n  \n  vec2 v_local_pos = (mm_FragNormCoord - v_square_center) / vec2(v_square_width, v_square_height);\n  \n  float v_led_size = fx_led_size * 0.5;\n  float v_feather = fx_led_feather;\n  \n  vec2 v_red_offset = vec2(fx_red_x, fx_red_y);\n  vec2 v_green_offset = vec2(fx_green_x, fx_green_y);\n  vec2 v_blue_offset = vec2(fx_blue_x, fx_blue_y);\n  \n  vec2 v_base_uv = v_square_center;\n  vec4 v_original_color = FX_NORM_PIXEL(v_base_uv);\n  \n  vec2 v_red_pos = v_local_pos - v_red_offset / vec2(v_square_width, v_square_height);\n  vec2 v_green_pos = v_local_pos - v_green_offset / vec2(v_square_width, v_square_height);\n  vec2 v_blue_pos = v_local_pos - v_blue_offset / vec2(v_square_width, v_square_height);\n  \n  float v_red_mask = f_smoothstep_square(v_red_pos, v_led_size, v_feather);\n  float v_green_mask = f_smoothstep_square(v_green_pos, v_led_size, v_feather);\n  float v_blue_mask = f_smoothstep_square(v_blue_pos, v_led_size, v_feather);\n  \n  vec3 v_final_color = vec3(0.0);\n  v_final_color += vec3(v_original_color.r * v_red_mask * fx_rgb_intensity, 0.0, 0.0);\n  v_final_color += vec3(0.0, v_original_color.g * v_green_mask * fx_rgb_intensity, 0.0);\n  v_final_color += vec3(0.0, 0.0, v_original_color.b * v_blue_mask * fx_rgb_intensity);\n  \n  return vec4(v_final_color, 1.0);\n}",
            "isPrompt": true,
            "madness": 0.5,
            "mode": "Higher quality",
            "title": "met les carré des leds en supperposition\n"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"MadTeam\",\n  \"DESCRIPTION\": \"LED Grid with RGB sub-pixels\",\n  \"TAGS\": \"graphics,led,rgb\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Grid/Width\", \"NAME\": \"fx_grid_width\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"Grid/Height\", \"NAME\": \"fx_grid_height\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"LED/Size\", \"NAME\": \"fx_led_size\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"LED/Feather\", \"NAME\": \"fx_led_feather\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 0.5, \"DEFAULT\": 0.1 },\n    { \"LABEL\": \"RGB/Red X\", \"NAME\": \"fx_red_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": -0.02 },\n    { \"LABEL\": \"RGB/Red Y\", \"NAME\": \"fx_red_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green X\", \"NAME\": \"fx_green_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green Y\", \"NAME\": \"fx_green_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Blue X\", \"NAME\": \"fx_blue_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.02 },\n    { \"LABEL\": \"RGB/Blue Y\", \"NAME\": \"fx_blue_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Intensity\", \"NAME\": \"fx_rgb_intensity\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 }\n  ]\n}*/\n\n// PARAMÈTRES SUPPLÉMENTAIRES SUGGÉRÉS :\n//\n// ASPECT VISUEL :\n// - \"LED/Brightness\" : Contrôle la luminosité globale des LEDs (utile pour simuler différentes intensités d'écran)\n// - \"LED/Contrast\" : Augmente le contraste entre les zones éclairées et sombres\n// - \"LED/Gap Color\" : Couleur de l'espace entre les LEDs (noir par défaut, mais peut être gris foncé pour un effet plus réaliste)\n// - \"LED/Gap Size\" : Taille de l'espace entre les LEDs (pour simuler la grille noire des écrans LED)\n// - \"LED/Shape\" : Forme des LEDs (carré, rond, hexagone) pour différents types d'écrans\n//\n// COULEURS :\n// - \"Color/Saturation\" : Contrôle la saturation des couleurs (écrans LED souvent très saturés)\n// - \"Color/Temperature\" : Balance des blancs (écrans chauds vs froids)\n// - \"Color/Gamma\" : Correction gamma pour simuler différents types d'écrans\n// - \"RGB/Balance\" : Balance individuelle R/G/B pour corriger les dominantes de couleur\n//\n// EFFETS TECHNIQUES :\n// - \"Screen/Scan Lines\" : Ajoute des lignes de balayage horizontales (effet CRT/LED)\n// - \"Screen/Flicker\" : Scintillement subtil pour simuler le rafraîchissement d'écran\n// - \"Screen/Moire\" : Effet de moiré quand la résolution ne correspond pas parfaitement\n// - \"Distortion/Barrel\" : Distorsion en barillet pour simuler la courbure d'un écran\n//\n// ANIMATION :\n// - \"Anim/Refresh Rate\" : Simule différents taux de rafraîchissement d'écran\n// - \"Anim/Persistence\" : Persistance rétinienne (traînées lumineuses)\n// - \"Anim/Phase Shift\" : Décalage temporel entre les sous-pixels RGB\n//\n// QUALITÉ/PERFORMANCE :\n// - \"Quality/Anti-alias\" : Niveau d'anticrénelage pour des bords plus lisses\n// - \"Quality/Dithering\" : Dithering pour simuler plus de couleurs avec moins de bits\n\nfloat f_smoothstep_square(vec2 p_pos, float p_size, float p_feather)\n{\n  vec2 v_d = abs(p_pos) - vec2(p_size);\n  float v_dist = length(max(v_d, 0.0)) + min(max(v_d.x, v_d.y), 0.0);\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n  float v_square_width = 1.0 / float(fx_grid_width);\n  float v_square_height = 1.0 / float(fx_grid_height);\n  float v_square_h_num = floor(mm_FragNormCoord.x / v_square_width);\n  float v_square_v_num = floor(mm_FragNormCoord.y / v_square_height);\n  vec2 v_square_center = vec2((0.5 + v_square_h_num) * v_square_width, (0.5 + v_square_v_num) * v_square_height);\n  \n  vec2 v_local_pos = (mm_FragNormCoord - v_square_center) / vec2(v_square_width, v_square_height);\n  \n  float v_led_size = fx_led_size * 0.5;\n  float v_feather = fx_led_feather;\n  \n  vec2 v_red_offset = vec2(fx_red_x, fx_red_y);\n  vec2 v_green_offset = vec2(fx_green_x, fx_green_y);\n  vec2 v_blue_offset = vec2(fx_blue_x, fx_blue_y);\n  \n  vec2 v_base_uv = v_square_center;\n  vec4 v_original_color = FX_NORM_PIXEL(v_base_uv);\n  \n  vec2 v_red_pos = v_local_pos - v_red_offset / vec2(v_square_width, v_square_height);\n  vec2 v_green_pos = v_local_pos - v_green_offset / vec2(v_square_width, v_square_height);\n  vec2 v_blue_pos = v_local_pos - v_blue_offset / vec2(v_square_width, v_square_height);\n  \n  float v_red_mask = f_smoothstep_square(v_red_pos, v_led_size, v_feather);\n  float v_green_mask = f_smoothstep_square(v_green_pos, v_led_size, v_feather);\n  float v_blue_mask = f_smoothstep_square(v_blue_pos, v_led_size, v_feather);\n  \n  vec3 v_final_color = vec3(0.0);\n  v_final_color += vec3(v_original_color.r * v_red_mask * fx_rgb_intensity, 0.0, 0.0);\n  v_final_color += vec3(0.0, v_original_color.g * v_green_mask * fx_rgb_intensity, 0.0);\n  v_final_color += vec3(0.0, 0.0, v_original_color.b * v_blue_mask * fx_rgb_intensity);\n  \n  return vec4(v_final_color, 1.0);\n}",
            "isPrompt": true,
            "madness": 0.5,
            "mode": "Higher quality",
            "title": "En ajoutant des commentaires au tout début du code, suggère-moi d'autres paramètres que je peux mettre et explique-moi à quoi ils peuvent servir. "
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"MadTeam\",\n  \"DESCRIPTION\": \"LED Grid with RGB sub-pixels\",\n  \"TAGS\": \"graphics,led,rgb\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Grid/Width\", \"NAME\": \"fx_grid_width\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"Grid/Height\", \"NAME\": \"fx_grid_height\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"LED/Size\", \"NAME\": \"fx_led_size\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"LED/Feather\", \"NAME\": \"fx_led_feather\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 0.5, \"DEFAULT\": 0.1 },\n    { \"LABEL\": \"LED/Brightness\", \"NAME\": \"fx_led_brightness\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"LED/Contrast\", \"NAME\": \"fx_led_contrast\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"LED/Gap Size\", \"NAME\": \"fx_gap_size\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 0.5, \"DEFAULT\": 0.05 },\n    { \"LABEL\": \"LED/Shape\", \"NAME\": \"fx_led_shape\", \"TYPE\": \"long\", \"DEFAULT\": \"0\", \"VALUES\": [0,1,2], \"LABELS\": [\"Square\", \"Round\", \"Hexagon\"] },\n    { \"LABEL\": \"RGB/Red X\", \"NAME\": \"fx_red_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": -0.02 },\n    { \"LABEL\": \"RGB/Red Y\", \"NAME\": \"fx_red_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green X\", \"NAME\": \"fx_green_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green Y\", \"NAME\": \"fx_green_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Blue X\", \"NAME\": \"fx_blue_x\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.02 },\n    { \"LABEL\": \"RGB/Blue Y\", \"NAME\": \"fx_blue_y\", \"TYPE\": \"float\", \"MIN\": -0.1, \"MAX\": 0.1, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Intensity\", \"NAME\": \"fx_rgb_intensity\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"RGB/R Balance\", \"NAME\": \"fx_red_balance\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"RGB/G Balance\", \"NAME\": \"fx_green_balance\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"RGB/B Balance\", \"NAME\": \"fx_blue_balance\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"Color/Saturation\", \"NAME\": \"fx_saturation\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"Color/Temperature\", \"NAME\": \"fx_temperature\", \"TYPE\": \"float\", \"MIN\": -1.0, \"MAX\": 1.0, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"Color/Gamma\", \"NAME\": \"fx_gamma\", \"TYPE\": \"float\", \"MIN\": 0.1, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"Quality/Antialias\", \"NAME\": \"fx_antialias\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 1.0, \"DEFAULT\": 0.5 },\n    { \"LABEL\": \"Quality/Dithering\", \"NAME\": \"fx_dithering\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 1.0, \"DEFAULT\": 0.0 }\n  ]\n}*/\n\nfloat f_hash(vec2 p_pos)\n{\n  return fract(sin(dot(p_pos, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat f_smoothstep_square(vec2 p_pos, float p_size, float p_feather)\n{\n  vec2 v_d = abs(p_pos) - vec2(p_size);\n  float v_dist = length(max(v_d, 0.0)) + min(max(v_d.x, v_d.y), 0.0);\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nfloat f_smoothstep_circle(vec2 p_pos, float p_size, float p_feather)\n{\n  float v_dist = length(p_pos) - p_size;\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nfloat f_smoothstep_hexagon(vec2 p_pos, float p_size, float p_feather)\n{\n  const vec3 v_k = vec3(-0.866025404, 0.5, 0.577350269);\n  p_pos = abs(p_pos);\n  p_pos -= 2.0 * min(dot(v_k.xy, p_pos), 0.0) * v_k.xy;\n  p_pos -= vec2(clamp(p_pos.x, -v_k.z * p_size, v_k.z * p_size), p_size);\n  float v_dist = length(p_pos) * sign(p_pos.y);\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nvec3 f_adjust_saturation(vec3 p_color, float p_saturation)\n{\n  float v_gray = dot(p_color, vec3(0.299, 0.587, 0.114));\n  return mix(vec3(v_gray), p_color, p_saturation);\n}\n\nvec3 f_adjust_temperature(vec3 p_color, float p_temperature)\n{\n  vec3 v_warm = p_color * vec3(1.0, 0.9, 0.8);\n  vec3 v_cool = p_color * vec3(0.8, 0.9, 1.0);\n  return mix(p_color, mix(v_cool, v_warm, p_temperature * 0.5 + 0.5), abs(p_temperature));\n}\n\nvec3 f_adjust_contrast(vec3 p_color, float p_contrast)\n{\n  return (p_color - 0.5) * p_contrast + 0.5;\n}\n\nvec3 f_apply_gamma(vec3 p_color, float p_gamma)\n{\n  return pow(max(p_color, vec3(0.0)), vec3(1.0 / p_gamma));\n}\n\nvec3 f_apply_dithering(vec3 p_color, vec2 p_pos, float p_amount)\n{\n  if (p_amount <= 0.0) return p_color;\n  \n  float v_noise = f_hash(p_pos) - 0.5;\n  return p_color + v_noise * p_amount * 0.1;\n}\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n  float v_square_width = 1.0 / float(fx_grid_width);\n  float v_square_height = 1.0 / float(fx_grid_height);\n  float v_square_h_num = floor(mm_FragNormCoord.x / v_square_width);\n  float v_square_v_num = floor(mm_FragNormCoord.y / v_square_height);\n  vec2 v_square_center = vec2((0.5 + v_square_h_num) * v_square_width, (0.5 + v_square_v_num) * v_square_height);\n  \n  vec2 v_local_pos = (mm_FragNormCoord - v_square_center) / vec2(v_square_width, v_square_height);\n  \n  float v_led_size = (fx_led_size - fx_gap_size) * 0.5;\n  float v_feather = fx_led_feather * (1.0 + fx_antialias);\n  \n  vec2 v_red_offset = vec2(fx_red_x, fx_red_y);\n  vec2 v_green_offset = vec2(fx_green_x, fx_green_y);\n  vec2 v_blue_offset = vec2(fx_blue_x, fx_blue_y);\n  \n  vec2 v_base_uv = v_square_center;\n  vec4 v_original_color = FX_NORM_PIXEL(v_base_uv);\n  \n  v_original_color.rgb = f_adjust_saturation(v_original_color.rgb, fx_saturation);\n  v_original_color.rgb = f_adjust_temperature(v_original_color.rgb, fx_temperature);\n  v_original_color.rgb = f_adjust_contrast(v_original_color.rgb, fx_led_contrast);\n  v_original_color.rgb = f_apply_gamma(v_original_color.rgb, fx_gamma);\n  v_original_color.rgb *= fx_led_brightness;\n  \n  vec2 v_red_pos = v_local_pos - v_red_offset / vec2(v_square_width, v_square_height);\n  vec2 v_green_pos = v_local_pos - v_green_offset / vec2(v_square_width, v_square_height);\n  vec2 v_blue_pos = v_local_pos - v_blue_offset / vec2(v_square_width, v_square_height);\n  \n  float v_red_mask, v_green_mask, v_blue_mask;\n  \n  if (fx_led_shape == 0) {\n    v_red_mask = f_smoothstep_square(v_red_pos, v_led_size, v_feather);\n    v_green_mask = f_smoothstep_square(v_green_pos, v_led_size, v_feather);\n    v_blue_mask = f_smoothstep_square(v_blue_pos, v_led_size, v_feather);\n  } else if (fx_led_shape == 1) {\n    v_red_mask = f_smoothstep_circle(v_red_pos, v_led_size, v_feather);\n    v_green_mask = f_smoothstep_circle(v_green_pos, v_led_size, v_feather);\n    v_blue_mask = f_smoothstep_circle(v_blue_pos, v_led_size, v_feather);\n  } else {\n    v_red_mask = f_smoothstep_hexagon(v_red_pos, v_led_size, v_feather);\n    v_green_mask = f_smoothstep_hexagon(v_green_pos, v_led_size, v_feather);\n    v_blue_mask = f_smoothstep_hexagon(v_blue_pos, v_led_size, v_feather);\n  }\n  \n  vec3 v_final_color = vec3(0.0);\n  v_final_color += vec3(v_original_color.r * v_red_mask * fx_rgb_intensity * fx_red_balance, 0.0, 0.0);\n  v_final_color += vec3(0.0, v_original_color.g * v_green_mask * fx_rgb_intensity * fx_green_balance, 0.0);\n  v_final_color += vec3(0.0, 0.0, v_original_color.b * v_blue_mask * fx_rgb_intensity * fx_blue_balance);\n  \n  v_final_color = f_apply_dithering(v_final_color, mm_FragNormCoord * vec2(fx_grid_width, fx_grid_height), fx_dithering);\n  \n  return vec4(v_final_color, 1.0);\n}",
            "isPrompt": true,
            "madness": 0.5,
            "mode": "Higher quality",
            "title": "ajoute les parametres -> \n\n\n// ASPECT VISUEL :\n// - \"LED/Brightness\" : Contrôle la luminosité globale des LEDs (utile pour simuler différentes intensités d'écran)\n// - \"LED/Contrast\" : Augmente le contraste entre les zones éclairées et sombres\n\n// - \"LED/Gap Size\" : Taille de l'espace entre les LEDs (pour simuler la grille noire des écrans LED)\n// - \"LED/Shape\" : Forme des LEDs (carré, rond, hexagone) pour différents types d'écrans\n//\n// COULEURS :\n// - \"Color/Saturation\" : Contrôle la saturation des couleurs (écrans LED souvent très saturés)\n// - \"Color/Temperature\" : Balance des blancs (écrans chauds vs froids)\n// - \"Color/Gamma\" : Correction gamma pour simuler différents types d'écrans\n// - \"RGB/Balance\" : Balance individuelle R/G/B pour corriger les dominantes de couleur\n\n\n// - \"Quality/Anti-alias\" : Niveau d'anticrénelage pour des bords plus lisses\n// - \"Quality/Dithering\" : Dithering pour simuler plus de couleurs avec moins de bits"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"MadTeam\",\n  \"DESCRIPTION\": \"LED Grid with RGB sub-pixels\",\n  \"TAGS\": \"graphics,led,rgb\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Grid/Width\", \"NAME\": \"fx_grid_width\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"Grid/Height\", \"NAME\": \"fx_grid_height\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 256, \"DEFAULT\": 32 },\n    { \"LABEL\": \"LED/Size\", \"NAME\": \"fx_led_size\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"LED/Feather\", \"NAME\": \"fx_led_feather\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 0.5, \"DEFAULT\": 0.1 },\n    { \"LABEL\": \"LED/Brightness\", \"NAME\": \"fx_led_brightness\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"LED/Contrast\", \"NAME\": \"fx_led_contrast\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"LED/Gap Size\", \"NAME\": \"fx_gap_size\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 0.5, \"DEFAULT\": 0.05 },\n    { \"LABEL\": \"LED/Shape\", \"NAME\": \"fx_led_shape\", \"TYPE\": \"long\", \"DEFAULT\": \"0\", \"VALUES\": [0,1,2], \"LABELS\": [\"Square\", \"Round\", \"Hexagon\"] },\n    { \"LABEL\": \"RGB/Red X\", \"NAME\": \"fx_red_x\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": -0.005 },\n    { \"LABEL\": \"RGB/Red Y\", \"NAME\": \"fx_red_y\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green X\", \"NAME\": \"fx_green_x\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green Y\", \"NAME\": \"fx_green_y\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Blue X\", \"NAME\": \"fx_blue_x\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": 0.005 },\n    { \"LABEL\": \"RGB/Blue Y\", \"NAME\": \"fx_blue_y\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Intensity\", \"NAME\": \"fx_rgb_intensity\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"RGB/R Balance\", \"NAME\": \"fx_red_balance\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"RGB/G Balance\", \"NAME\": \"fx_green_balance\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"RGB/B Balance\", \"NAME\": \"fx_blue_balance\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"Color/Saturation\", \"NAME\": \"fx_saturation\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"Color/Temperature\", \"NAME\": \"fx_temperature\", \"TYPE\": \"float\", \"MIN\": -1.0, \"MAX\": 1.0, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"Color/Gamma\", \"NAME\": \"fx_gamma\", \"TYPE\": \"float\", \"MIN\": 0.1, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"Quality/Antialias\", \"NAME\": \"fx_antialias\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 1.0, \"DEFAULT\": 0.5 },\n    { \"LABEL\": \"Quality/Dithering\", \"NAME\": \"fx_dithering\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 1.0, \"DEFAULT\": 0.0 }\n  ]\n}*/\n\nfloat f_hash(vec2 p_pos)\n{\n  return fract(sin(dot(p_pos, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat f_smoothstep_square(vec2 p_pos, float p_size, float p_feather)\n{\n  vec2 v_d = abs(p_pos) - vec2(p_size);\n  float v_dist = length(max(v_d, 0.0)) + min(max(v_d.x, v_d.y), 0.0);\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nfloat f_smoothstep_circle(vec2 p_pos, float p_size, float p_feather)\n{\n  float v_dist = length(p_pos) - p_size;\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nfloat f_smoothstep_hexagon(vec2 p_pos, float p_size, float p_feather)\n{\n  const vec3 v_k = vec3(-0.866025404, 0.5, 0.577350269);\n  p_pos = abs(p_pos);\n  p_pos -= 2.0 * min(dot(v_k.xy, p_pos), 0.0) * v_k.xy;\n  p_pos -= vec2(clamp(p_pos.x, -v_k.z * p_size, v_k.z * p_size), p_size);\n  float v_dist = length(p_pos) * sign(p_pos.y);\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nvec3 f_adjust_saturation(vec3 p_color, float p_saturation)\n{\n  float v_gray = dot(p_color, vec3(0.299, 0.587, 0.114));\n  return mix(vec3(v_gray), p_color, p_saturation);\n}\n\nvec3 f_adjust_temperature(vec3 p_color, float p_temperature)\n{\n  vec3 v_warm = p_color * vec3(1.0, 0.9, 0.8);\n  vec3 v_cool = p_color * vec3(0.8, 0.9, 1.0);\n  return mix(p_color, mix(v_cool, v_warm, p_temperature * 0.5 + 0.5), abs(p_temperature));\n}\n\nvec3 f_adjust_contrast(vec3 p_color, float p_contrast)\n{\n  return (p_color - 0.5) * p_contrast + 0.5;\n}\n\nvec3 f_apply_gamma(vec3 p_color, float p_gamma)\n{\n  return pow(max(p_color, vec3(0.0)), vec3(1.0 / p_gamma));\n}\n\nvec3 f_apply_dithering(vec3 p_color, vec2 p_pos, float p_amount)\n{\n  if (p_amount <= 0.0) return p_color;\n  \n  float v_noise = f_hash(p_pos) - 0.5;\n  return p_color + v_noise * p_amount * 0.1;\n}\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n  float v_square_width = 1.0 / float(fx_grid_width);\n  float v_square_height = 1.0 / float(fx_grid_height);\n  float v_square_h_num = floor(mm_FragNormCoord.x / v_square_width);\n  float v_square_v_num = floor(mm_FragNormCoord.y / v_square_height);\n  vec2 v_square_center = vec2((0.5 + v_square_h_num) * v_square_width, (0.5 + v_square_v_num) * v_square_height);\n  \n  vec2 v_local_pos = (mm_FragNormCoord - v_square_center) / vec2(v_square_width, v_square_height);\n  \n  float v_led_size = (fx_led_size - fx_gap_size) * 0.5;\n  float v_feather = fx_led_feather * (1.0 + fx_antialias);\n  \n  vec2 v_red_offset = vec2(fx_red_x, fx_red_y);\n  vec2 v_green_offset = vec2(fx_green_x, fx_green_y);\n  vec2 v_blue_offset = vec2(fx_blue_x, fx_blue_y);\n  \n  vec2 v_base_uv = v_square_center;\n  vec4 v_original_color = FX_NORM_PIXEL(v_base_uv);\n  \n  v_original_color.rgb = f_adjust_saturation(v_original_color.rgb, fx_saturation);\n  v_original_color.rgb = f_adjust_temperature(v_original_color.rgb, fx_temperature);\n  v_original_color.rgb = f_adjust_contrast(v_original_color.rgb, fx_led_contrast);\n  v_original_color.rgb = f_apply_gamma(v_original_color.rgb, fx_gamma);\n  v_original_color.rgb *= fx_led_brightness;\n  \n  vec2 v_red_pos = v_local_pos - v_red_offset / vec2(v_square_width, v_square_height);\n  vec2 v_green_pos = v_local_pos - v_green_offset / vec2(v_square_width, v_square_height);\n  vec2 v_blue_pos = v_local_pos - v_blue_offset / vec2(v_square_width, v_square_height);\n  \n  float v_red_mask, v_green_mask, v_blue_mask;\n  \n  if (fx_led_shape == 0) {\n    v_red_mask = f_smoothstep_square(v_red_pos, v_led_size, v_feather);\n    v_green_mask = f_smoothstep_square(v_green_pos, v_led_size, v_feather);\n    v_blue_mask = f_smoothstep_square(v_blue_pos, v_led_size, v_feather);\n  } else if (fx_led_shape == 1) {\n    v_red_mask = f_smoothstep_circle(v_red_pos, v_led_size, v_feather);\n    v_green_mask = f_smoothstep_circle(v_green_pos, v_led_size, v_feather);\n    v_blue_mask = f_smoothstep_circle(v_blue_pos, v_led_size, v_feather);\n  } else {\n    v_red_mask = f_smoothstep_hexagon(v_red_pos, v_led_size, v_feather);\n    v_green_mask = f_smoothstep_hexagon(v_green_pos, v_led_size, v_feather);\n    v_blue_mask = f_smoothstep_hexagon(v_blue_pos, v_led_size, v_feather);\n  }\n  \n  vec3 v_final_color = vec3(0.0);\n  v_final_color += vec3(v_original_color.r * v_red_mask * fx_rgb_intensity * fx_red_balance, 0.0, 0.0);\n  v_final_color += vec3(0.0, v_original_color.g * v_green_mask * fx_rgb_intensity * fx_green_balance, 0.0);\n  v_final_color += vec3(0.0, 0.0, v_original_color.b * v_blue_mask * fx_rgb_intensity * fx_blue_balance);\n  \n  v_final_color = f_apply_dithering(v_final_color, mm_FragNormCoord * vec2(fx_grid_width, fx_grid_height), fx_dithering);\n  \n  return vec4(v_final_color, 1.0);\n}",
            "isPrompt": true,
            "madness": 0.5,
            "mode": "Higher quality",
            "title": "permet au parametre red x red y blue x blue y green x green y d'aller que de -0,01 à 0,01"
        },
        {
            "code": "/*{\n  \"RESOURCE_TYPE\": \"Surface 2D FX For MadMapper\",\n  \"CREDIT\": \"MadTeam\",\n  \"DESCRIPTION\": \"LED Grid with RGB sub-pixels\",\n  \"TAGS\": \"graphics,led,rgb\",\n  \"VSN\": \"1.0\",\n  \"INPUTS\": [\n    { \"LABEL\": \"Grid/Width\", \"NAME\": \"fx_grid_width\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 3500, \"DEFAULT\": 32 },\n    { \"LABEL\": \"Grid/Height\", \"NAME\": \"fx_grid_height\", \"TYPE\": \"int\", \"MIN\": 1, \"MAX\": 3500, \"DEFAULT\": 32 },\n    { \"LABEL\": \"LED/Size\", \"NAME\": \"fx_led_size\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 1, \"DEFAULT\": 0.8 },\n    { \"LABEL\": \"LED/Feather\", \"NAME\": \"fx_led_feather\", \"TYPE\": \"float\", \"MIN\": 0, \"MAX\": 0.5, \"DEFAULT\": 0.1 },\n    { \"LABEL\": \"LED/Brightness\", \"NAME\": \"fx_led_brightness\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"LED/Contrast\", \"NAME\": \"fx_led_contrast\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"LED/Gap Size\", \"NAME\": \"fx_gap_size\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 0.5, \"DEFAULT\": 0.05 },\n    { \"LABEL\": \"LED/Shape\", \"NAME\": \"fx_led_shape\", \"TYPE\": \"long\", \"DEFAULT\": \"0\", \"VALUES\": [0,1,2], \"LABELS\": [\"Square\", \"Round\", \"Hexagon\"] },\n    { \"LABEL\": \"RGB/Red X\", \"NAME\": \"fx_red_x\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": -0.005 },\n    { \"LABEL\": \"RGB/Red Y\", \"NAME\": \"fx_red_y\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green X\", \"NAME\": \"fx_green_x\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Green Y\", \"NAME\": \"fx_green_y\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Blue X\", \"NAME\": \"fx_blue_x\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": 0.005 },\n    { \"LABEL\": \"RGB/Blue Y\", \"NAME\": \"fx_blue_y\", \"TYPE\": \"float\", \"MIN\": -0.01, \"MAX\": 0.01, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"RGB/Intensity\", \"NAME\": \"fx_rgb_intensity\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"RGB/R Balance\", \"NAME\": \"fx_red_balance\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"RGB/G Balance\", \"NAME\": \"fx_green_balance\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"RGB/B Balance\", \"NAME\": \"fx_blue_balance\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"Color/Saturation\", \"NAME\": \"fx_saturation\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"Color/Temperature\", \"NAME\": \"fx_temperature\", \"TYPE\": \"float\", \"MIN\": -1.0, \"MAX\": 1.0, \"DEFAULT\": 0.0 },\n    { \"LABEL\": \"Color/Gamma\", \"NAME\": \"fx_gamma\", \"TYPE\": \"float\", \"MIN\": 0.1, \"MAX\": 3.0, \"DEFAULT\": 1.0 },\n    { \"LABEL\": \"Quality/Antialias\", \"NAME\": \"fx_antialias\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 1.0, \"DEFAULT\": 0.5 },\n    { \"LABEL\": \"Quality/Dithering\", \"NAME\": \"fx_dithering\", \"TYPE\": \"float\", \"MIN\": 0.0, \"MAX\": 1.0, \"DEFAULT\": 0.0 }\n  ]\n}*/\n\nfloat f_hash(vec2 p_pos)\n{\n  return fract(sin(dot(p_pos, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat f_smoothstep_square(vec2 p_pos, float p_size, float p_feather)\n{\n  vec2 v_d = abs(p_pos) - vec2(p_size);\n  float v_dist = length(max(v_d, 0.0)) + min(max(v_d.x, v_d.y), 0.0);\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nfloat f_smoothstep_circle(vec2 p_pos, float p_size, float p_feather)\n{\n  float v_dist = length(p_pos) - p_size;\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nfloat f_smoothstep_hexagon(vec2 p_pos, float p_size, float p_feather)\n{\n  const vec3 v_k = vec3(-0.866025404, 0.5, 0.577350269);\n  p_pos = abs(p_pos);\n  p_pos -= 2.0 * min(dot(v_k.xy, p_pos), 0.0) * v_k.xy;\n  p_pos -= vec2(clamp(p_pos.x, -v_k.z * p_size, v_k.z * p_size), p_size);\n  float v_dist = length(p_pos) * sign(p_pos.y);\n  return 1.0 - smoothstep(-p_feather, p_feather, v_dist);\n}\n\nvec3 f_adjust_saturation(vec3 p_color, float p_saturation)\n{\n  float v_gray = dot(p_color, vec3(0.299, 0.587, 0.114));\n  return mix(vec3(v_gray), p_color, p_saturation);\n}\n\nvec3 f_adjust_temperature(vec3 p_color, float p_temperature)\n{\n  vec3 v_warm = p_color * vec3(1.0, 0.9, 0.8);\n  vec3 v_cool = p_color * vec3(0.8, 0.9, 1.0);\n  return mix(p_color, mix(v_cool, v_warm, p_temperature * 0.5 + 0.5), abs(p_temperature));\n}\n\nvec3 f_adjust_contrast(vec3 p_color, float p_contrast)\n{\n  return (p_color - 0.5) * p_contrast + 0.5;\n}\n\nvec3 f_apply_gamma(vec3 p_color, float p_gamma)\n{\n  return pow(max(p_color, vec3(0.0)), vec3(1.0 / p_gamma));\n}\n\nvec3 f_apply_dithering(vec3 p_color, vec2 p_pos, float p_amount)\n{\n  if (p_amount <= 0.0) return p_color;\n  \n  float v_noise = f_hash(p_pos) - 0.5;\n  return p_color + v_noise * p_amount * 0.1;\n}\n\nvec4 fxColorForPixel(vec2 mm_FragNormCoord)\n{\n  float v_square_width = 1.0 / float(fx_grid_width);\n  float v_square_height = 1.0 / float(fx_grid_height);\n  float v_square_h_num = floor(mm_FragNormCoord.x / v_square_width);\n  float v_square_v_num = floor(mm_FragNormCoord.y / v_square_height);\n  vec2 v_square_center = vec2((0.5 + v_square_h_num) * v_square_width, (0.5 + v_square_v_num) * v_square_height);\n  \n  vec2 v_local_pos = (mm_FragNormCoord - v_square_center) / vec2(v_square_width, v_square_height);\n  \n  float v_led_size = (fx_led_size - fx_gap_size) * 0.5;\n  float v_feather = fx_led_feather * (1.0 + fx_antialias);\n  \n  vec2 v_red_offset = vec2(fx_red_x, fx_red_y);\n  vec2 v_green_offset = vec2(fx_green_x, fx_green_y);\n  vec2 v_blue_offset = vec2(fx_blue_x, fx_blue_y);\n  \n  vec2 v_base_uv = v_square_center;\n  vec4 v_original_color = FX_NORM_PIXEL(v_base_uv);\n  \n  v_original_color.rgb = f_adjust_saturation(v_original_color.rgb, fx_saturation);\n  v_original_color.rgb = f_adjust_temperature(v_original_color.rgb, fx_temperature);\n  v_original_color.rgb = f_adjust_contrast(v_original_color.rgb, fx_led_contrast);\n  v_original_color.rgb = f_apply_gamma(v_original_color.rgb, fx_gamma);\n  v_original_color.rgb *= fx_led_brightness;\n  \n  vec2 v_red_pos = v_local_pos - v_red_offset / vec2(v_square_width, v_square_height);\n  vec2 v_green_pos = v_local_pos - v_green_offset / vec2(v_square_width, v_square_height);\n  vec2 v_blue_pos = v_local_pos - v_blue_offset / vec2(v_square_width, v_square_height);\n  \n  float v_red_mask, v_green_mask, v_blue_mask;\n  \n  if (fx_led_shape == 0) {\n    v_red_mask = f_smoothstep_square(v_red_pos, v_led_size, v_feather);\n    v_green_mask = f_smoothstep_square(v_green_pos, v_led_size, v_feather);\n    v_blue_mask = f_smoothstep_square(v_blue_pos, v_led_size, v_feather);\n  } else if (fx_led_shape == 1) {\n    v_red_mask = f_smoothstep_circle(v_red_pos, v_led_size, v_feather);\n    v_green_mask = f_smoothstep_circle(v_green_pos, v_led_size, v_feather);\n    v_blue_mask = f_smoothstep_circle(v_blue_pos, v_led_size, v_feather);\n  } else {\n    v_red_mask = f_smoothstep_hexagon(v_red_pos, v_led_size, v_feather);\n    v_green_mask = f_smoothstep_hexagon(v_green_pos, v_led_size, v_feather);\n    v_blue_mask = f_smoothstep_hexagon(v_blue_pos, v_led_size, v_feather);\n  }\n  \n  vec3 v_final_color = vec3(0.0);\n  v_final_color += vec3(v_original_color.r * v_red_mask * fx_rgb_intensity * fx_red_balance, 0.0, 0.0);\n  v_final_color += vec3(0.0, v_original_color.g * v_green_mask * fx_rgb_intensity * fx_green_balance, 0.0);\n  v_final_color += vec3(0.0, 0.0, v_original_color.b * v_blue_mask * fx_rgb_intensity * fx_blue_balance);\n  \n  v_final_color = f_apply_dithering(v_final_color, mm_FragNormCoord * vec2(fx_grid_width, fx_grid_height), fx_dithering);\n  \n  return vec4(v_final_color, 1.0);\n}",
            "isPrompt": true,
            "madness": 0.5,
            "mode": "Higher quality",
            "title": "permet à simulation grid d'aller jusqu'à 3500\n"
        }
    ],
    "index": 10
}
